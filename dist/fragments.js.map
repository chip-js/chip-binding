{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "index.js",
    "node_modules/chip-utils/class.js",
    "node_modules/differences-js/index.js",
    "node_modules/differences-js/src/diff.js",
    "node_modules/expressions-js/index.js",
    "node_modules/expressions-js/src/expressions.js",
    "node_modules/expressions-js/src/formatters.js",
    "node_modules/expressions-js/src/property-chains.js",
    "node_modules/expressions-js/src/strings.js",
    "node_modules/observations-js/index.js",
    "node_modules/observations-js/src/computed-properties/computed-property.js",
    "node_modules/observations-js/src/computed-properties/expr.js",
    "node_modules/observations-js/src/computed-properties/if.js",
    "node_modules/observations-js/src/computed-properties/map.js",
    "node_modules/observations-js/src/computed-properties/when.js",
    "node_modules/observations-js/src/computed.js",
    "node_modules/observations-js/src/observable-hash.js",
    "node_modules/observations-js/src/observations.js",
    "node_modules/observations-js/src/observer.js",
    "src/animated-binding.js",
    "src/binding.js",
    "src/compile.js",
    "src/element-controller.js",
    "src/fragments.js",
    "src/template.js",
    "src/util/animation.js",
    "src/util/polyfills.js",
    "src/util/toFragment.js",
    "src/view.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrHA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpZA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "var Fragments = require('./src/fragments');\nvar Observations = require('observations-js');\n\nfunction create(options) {\n  options = options || {};\n  var observations = Observations.create();\n  options.observations = observations;\n  var fragments = new Fragments(options);\n  fragments.sync = observations.sync;\n  fragments.syncNow = observations.syncNow;\n  fragments.afterSync = observations.afterSync;\n  fragments.onSync = observations.onSync;\n  fragments.offSync = observations.offSync;\n  return fragments;\n}\n\n// Create an instance of fragments with the default observer\nexports.create = create;\n",
    "var slice = Array.prototype.slice;\n\n/**\n * Simplifies extending classes and provides static inheritance. Classes that need to be extendable should\n * extend Class which will give them the `extend` static function for their subclasses to use. In addition to\n * a prototype, mixins may be added as well. Example:\n *\n * function MyClass(arg1, arg2) {\n *   SuperClass.call(this, arg1);\n *   this.arg2 = arg2;\n * }\n * SuperClass.extend(MyClass, mixin1, AnotherClass, {\n *   foo: function() {\n *     this._bar++;\n *   },\n *   get bar() {\n *     return this._bar;\n *   }\n * });\n *\n * In addition to extending the superclass, static methods and properties will be copied onto the subclass for\n * static inheritance. This allows the extend function to be copied to the subclass so that it may be\n * subclassed as well. Additionally, static properties may be added by defining them on a special prototype\n * property `static` making the code more readable.\n *\n * @param {function} The subclass constructor.\n * @param {object} [optional] Zero or more mixins. They can be objects or classes (functions).\n * @param {object} The prototype of the subclass.\n */\nfunction Class() {}\nClass.extend = extend;\nClass.makeInstanceOf = makeInstanceOf;\nmodule.exports = Class;\n\nfunction extend(Subclass /* [, prototype [,prototype]] */) {\n  var prototypes, SuperClass = this;\n\n  // Support no constructor\n  if (typeof Subclass !== 'function') {\n    prototypes = slice.call(arguments);\n    Subclass = function() {\n      SuperClass.apply(this, arguments);\n    };\n  } else {\n    prototypes = slice.call(arguments, 1);\n  }\n\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(Subclass, this);\n  } else {\n    Subclass.__proto__ = this;\n  }\n\n  prototypes.forEach(function(proto) {\n    if (typeof proto === 'function') {\n      addStatics(proto, Subclass);\n    } else if (proto.hasOwnProperty('static')) {\n      addStatics(proto.static, Subclass);\n    }\n  });\n\n  var descriptors = getDescriptors(prototypes);\n  descriptors.constructor = { writable: true, configurable: true, value: Subclass };\n  descriptors.super = { configurable: true, value: SuperClass.prototype };\n  Subclass.prototype = Object.create(this.prototype, descriptors);\n  if (typeof SuperClass.onExtend === 'function') {\n    // Allow for customizing the definitions of your child classes\n    SuperClass.onExtend(Subclass, prototypes);\n  }\n  return Subclass;\n}\n\n// Get descriptors (allows for getters and setters) and sets functions to be non-enumerable\nfunction getDescriptors(objects) {\n  var descriptors = {};\n\n  objects.forEach(function(object) {\n    if (typeof object === 'function') object = object.prototype;\n\n    Object.getOwnPropertyNames(object).forEach(function(name) {\n      if (name === 'static') return;\n\n      var descriptor = Object.getOwnPropertyDescriptor(object, name);\n\n      if (typeof descriptor.value === 'function') {\n        descriptor.enumerable = false;\n      }\n\n      descriptors[name] = descriptor;\n    });\n  });\n  return descriptors;\n}\n\n// Copies static methods over for static inheritance\nfunction addStatics(statics, Subclass) {\n\n  // static method inheritance (including `extend`)\n  Object.keys(statics).forEach(function(key) {\n    var descriptor = Object.getOwnPropertyDescriptor(statics, key);\n    if (!descriptor.configurable) return;\n\n    Object.defineProperty(Subclass, key, descriptor);\n  });\n}\n\n\n/**\n * Makes a native object pretend to be an instance of class (e.g. adds methods to a DocumentFragment then calls the\n * constructor).\n */\nfunction makeInstanceOf(object) {\n  var args = slice.call(arguments, 1);\n  Object.defineProperties(object, getDescriptors([this.prototype]));\n  this.apply(object, args);\n  return object;\n}\n",
    "module.exports = require('./src/diff');\n",
    "/*\nCopyright (c) 2015 Jacob Wright <jacwright@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n// # Diff\n// > Based on work from Google's observe-js polyfill: https://github.com/Polymer/observe-js\n\n// A namespace to store the functions on\nvar diff = exports;\n\n(function() {\n\n  diff.clone = clone;\n  diff.values = diffValues;\n  diff.basic = diffBasic;\n  diff.objects = diffObjects;\n  diff.arrays = diffArrays;\n\n\n  // A change record for the object changes\n  function ChangeRecord(object, type, name, oldValue) {\n    this.object = object;\n    this.type = type;\n    this.name = name;\n    this.oldValue = oldValue;\n  }\n\n  // A splice record for the array changes\n  function Splice(object, index, removed, addedCount) {\n    ChangeRecord.call(this, object, 'splice', String(index));\n    this.index = index;\n    this.removed = removed;\n    this.addedCount = addedCount;\n  }\n\n  Splice.prototype = Object.create(ChangeRecord.prototype);\n\n\n  // Creates a clone or copy of an array or object (or simply returns a string/number/boolean which are immutable)\n  // Does not provide deep copies.\n  function clone(value, deep) {\n    if (Array.isArray(value)) {\n      if (deep) {\n        return value.map(function(value) {\n          return clone(value, deep);\n        });\n      } else {\n        return value.slice();\n      }\n    } else if (value && typeof value === 'object') {\n      if (value.valueOf() !== value) {\n        return new value.constructor(value.valueOf());\n      } else {\n        var copy = {};\n        for (var key in value) {\n          var objValue = value[key];\n          if (deep) {\n            objValue = clone(objValue, deep);\n          }\n          copy[key] = objValue;\n        }\n        return copy;\n      }\n    } else {\n      return value;\n    }\n  }\n\n\n  // Diffs two values, returning a truthy value if there are changes or `false` if there are no changes. If the two\n  // values are both arrays or both objects, an array of changes (splices or change records) between the two will be\n  // returned. Otherwise  `true` will be returned.\n  function diffValues(value, oldValue) {\n    // Shortcut out for values that are exactly equal\n    if (value === oldValue) return false;\n\n    if (Array.isArray(value) && Array.isArray(oldValue)) {\n      // If an array has changed calculate the splices\n      var splices = diffArrays(value, oldValue);\n      return splices.length ? splices : false;\n    } else if (value && oldValue && typeof value === 'object' && typeof oldValue === 'object') {\n      // If an object has changed calculate the chnages and call the callback\n      // Allow dates and Number/String objects to be compared\n      var valueValue = value.valueOf();\n      var oldValueValue = oldValue.valueOf();\n\n      // Allow dates and Number/String objects to be compared\n      if (typeof valueValue !== 'object' && typeof oldValueValue !== 'object') {\n        return valueValue !== oldValueValue;\n      } else {\n        var changeRecords = diffObjects(value, oldValue);\n        return changeRecords.length ? changeRecords : false;\n      }\n    } else {\n      // If a value has changed call the callback\n      return diffBasic(value, oldValue);\n    }\n  }\n\n\n  // Diffs two basic types, returning true if changed or false if not\n  function diffBasic(value, oldValue) {\n    if (value && oldValue && typeof value === 'object' && typeof oldValue === 'object') {\n      // Allow dates and Number/String objects to be compared\n      var valueValue = value.valueOf();\n      var oldValueValue = oldValue.valueOf();\n\n      // Allow dates and Number/String objects to be compared\n      if (typeof valueValue !== 'object' && typeof oldValueValue !== 'object') {\n        return diffBasic(valueValue, oldValueValue);\n      }\n    }\n\n    // If a value has changed call the callback\n    if (typeof value === 'number' && typeof oldValue === 'number' && isNaN(value) && isNaN(oldValue)) {\n      return false;\n    } else {\n      return value !== oldValue;\n    }\n  }\n\n\n  // Diffs two objects returning an array of change records. The change record looks like:\n  // ```javascript\n  // {\n  //   object: object,\n  //   type: 'delete|update|add',\n  //   name: 'propertyName',\n  //   oldValue: oldValue\n  // }\n  // ```\n  function diffObjects(value, oldValue) {\n    if ( !(value && oldValue && typeof value === 'object' && typeof oldValue === 'object')) {\n      throw new TypeError('Both values for diff.object must be objects');\n    }\n    var changeRecords = [];\n    var prop, propOldValue, propValue;\n\n    // Goes through the old object (should be a clone) and look for things that are now gone or changed\n    for (prop in oldValue) {\n      propOldValue = oldValue[prop];\n      propValue = value[prop];\n\n      // Allow for the case of obj.prop = undefined (which is a new property, even if it is undefined)\n      if (propValue !== undefined && !diffBasic(propValue, propOldValue)) {\n        continue;\n      }\n\n      // If the property is gone it was removed\n      if (! (prop in value)) {\n        changeRecords.push(new ChangeRecord(value, 'delete', prop, propOldValue));\n      } else if (diffBasic(propValue, propOldValue)) {\n        changeRecords.push(new ChangeRecord(value, 'update', prop, propOldValue));\n      }\n    }\n\n    // Goes through the old object and looks for things that are new\n    for (prop in value) {\n      propValue = value[prop];\n      if (! (prop in oldValue)) {\n        changeRecords.push(new ChangeRecord(value, 'add', prop));\n      }\n    }\n\n    if (Array.isArray(value) && value.length !== oldValue.length) {\n      changeRecords.push(new ChangeRecord(value, 'update', 'length', oldValue.length));\n    }\n\n    return changeRecords;\n  }\n\n\n\n\n\n  var EDIT_LEAVE = 0;\n  var EDIT_UPDATE = 1;\n  var EDIT_ADD = 2;\n  var EDIT_DELETE = 3;\n\n\n  // Diffs two arrays returning an array of splices. A splice object looks like:\n  // ```javascript\n  // {\n  //   index: 3,\n  //   removed: [item, item],\n  //   addedCount: 0\n  // }\n  // ```\n  function diffArrays(value, oldValue) {\n    if (!Array.isArray(value) || !Array.isArray(oldValue)) {\n      throw new TypeError('Both values for diff.array must be arrays');\n    }\n\n    var currentStart = 0;\n    var currentEnd = value.length;\n    var oldStart = 0;\n    var oldEnd = oldValue.length;\n\n    var minLength = Math.min(currentEnd, oldEnd);\n    var prefixCount = sharedPrefix(value, oldValue, minLength);\n    var suffixCount = sharedSuffix(value, oldValue, minLength - prefixCount);\n\n    currentStart += prefixCount;\n    oldStart += prefixCount;\n    currentEnd -= suffixCount;\n    oldEnd -= suffixCount;\n\n    if (currentEnd - currentStart === 0 && oldEnd - oldStart === 0) {\n      return [];\n    }\n\n    // if nothing was added, only removed from one spot\n    if (currentStart === currentEnd) {\n      return [ new Splice(value, currentStart, oldValue.slice(oldStart, oldEnd), 0) ];\n    }\n\n    // if nothing was removed, only added to one spot\n    if (oldStart === oldEnd) {\n      return [ new Splice(value, currentStart, [], currentEnd - currentStart) ];\n    }\n\n    // a mixture of adds and removes\n    var distances = calcEditDistances(value, currentStart, currentEnd, oldValue, oldStart, oldEnd);\n    var ops = spliceOperationsFromEditDistances(distances);\n\n    var splice = null;\n    var splices = [];\n    var index = currentStart;\n    var oldIndex = oldStart;\n\n    for (var i = 0, l = ops.length; i < l; i++) {\n      var op = ops[i];\n      if (op === EDIT_LEAVE) {\n        if (splice) {\n          splices.push(splice);\n          splice = null;\n        }\n\n        index++;\n        oldIndex++;\n      } else if (op === EDIT_UPDATE) {\n        if (!splice) {\n          splice = new Splice(value, index, [], 0);\n        }\n\n        splice.addedCount++;\n        index++;\n\n        splice.removed.push(oldValue[oldIndex]);\n        oldIndex++;\n      } else if (op === EDIT_ADD) {\n        if (!splice) {\n          splice = new Splice(value, index, [], 0);\n        }\n\n        splice.addedCount++;\n        index++;\n      } else if (op === EDIT_DELETE) {\n        if (!splice) {\n          splice = new Splice(value, index, [], 0);\n        }\n\n        splice.removed.push(oldValue[oldIndex]);\n        oldIndex++;\n      }\n    }\n\n    if (splice) {\n      splices.push(splice);\n    }\n\n    return splices;\n  }\n\n\n\n\n  // find the number of items at the beginning that are the same\n  function sharedPrefix(current, old, searchLength) {\n    for (var i = 0; i < searchLength; i++) {\n      if (diffBasic(current[i], old[i])) {\n        return i;\n      }\n    }\n    return searchLength;\n  }\n\n\n  // find the number of items at the end that are the same\n  function sharedSuffix(current, old, searchLength) {\n    var index1 = current.length;\n    var index2 = old.length;\n    var count = 0;\n    while (count < searchLength && !diffBasic(current[--index1], old[--index2])) {\n      count++;\n    }\n    return count;\n  }\n\n\n  function spliceOperationsFromEditDistances(distances) {\n    var i = distances.length - 1;\n    var j = distances[0].length - 1;\n    var current = distances[i][j];\n    var edits = [];\n    while (i > 0 || j > 0) {\n      if (i === 0) {\n        edits.push(EDIT_ADD);\n        j--;\n        continue;\n      }\n\n      if (j === 0) {\n        edits.push(EDIT_DELETE);\n        i--;\n        continue;\n      }\n\n      var northWest = distances[i - 1][j - 1];\n      var west = distances[i - 1][j];\n      var north = distances[i][j - 1];\n      var min;\n\n      if (west < north) {\n        min = west < northWest ? west : northWest;\n      } else {\n        min = north < northWest ? north : northWest;\n      }\n\n      if (min === northWest) {\n        if (northWest === current) {\n          edits.push(EDIT_LEAVE);\n        } else {\n          edits.push(EDIT_UPDATE);\n          current = northWest;\n        }\n        i--;\n        j--;\n      } else if (min === west) {\n        edits.push(EDIT_DELETE);\n        i--;\n        current = west;\n      } else {\n        edits.push(EDIT_ADD);\n        j--;\n        current = north;\n      }\n    }\n    edits.reverse();\n    return edits;\n  }\n\n\n  function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n    // \"Deletion\" columns\n    var rowCount = oldEnd - oldStart + 1;\n    var columnCount = currentEnd - currentStart + 1;\n    var distances = new Array(rowCount);\n    var i, j;\n\n    // \"Addition\" rows. Initialize null column.\n    for (i = 0; i < rowCount; i++) {\n      distances[i] = new Array(columnCount);\n      distances[i][0] = i;\n    }\n\n    // Initialize null row\n    for (j = 0; j < columnCount; j++) {\n      distances[0][j] = j;\n    }\n\n    for (i = 1; i < rowCount; i++) {\n      for (j = 1; j < columnCount; j++) {\n        if (!diffBasic(current[currentStart + j - 1], old[oldStart + i - 1])) {\n          distances[i][j] = distances[i - 1][j - 1];\n        } else {\n          var north = distances[i - 1][j] + 1;\n          var west = distances[i][j - 1] + 1;\n          distances[i][j] = north < west ? north : west;\n        }\n      }\n    }\n\n    return distances;\n  }\n})();\n",
    "module.exports = require('./src/expressions');\n",
    "var slice = Array.prototype.slice;\nvar strings = require('./strings');\nvar formatterParser = require('./formatters');\nvar propertyChains = require('./property-chains');\nvar valueProperty = '_value_';\nvar cache = {};\n\nexports.globals = {};\n\n\nexports.parse = function(expr, globals, formatters) {\n  if (typeof expr !== 'string') {\n    throw new TypeError('Invalid expr, must be type String');\n  }\n  var extraArgs = slice.call(arguments, 3);\n  var cacheKey = expr + '|' + extraArgs.join(',');\n  // Returns the cached function for this expression if it exists.\n  var func = cache[cacheKey];\n  if (func) {\n    return func;\n  }\n\n  var original = expr;\n  var isSetter = (extraArgs[0] === valueProperty);\n\n  expr = strings.pullOutStrings(expr);\n  expr = formatterParser.parseFormatters(expr);\n  expr = propertyChains.parseExpression(expr, getVariables(globals, extraArgs));\n  if (!isSetter) {\n    var lines = expr.split('\\n');\n    lines[lines.length - 1] = 'return ' + lines[lines.length - 1];\n    expr = lines.join('\\n');\n  }\n  expr = strings.putInStrings(expr);\n  func = compileExpression(original, expr, globals, formatters, extraArgs);\n  func.expr = expr;\n  cache[cacheKey] = func;\n  return func;\n};\n\n\nexports.parseSetter = function(expr, globals, formatters, extraArgs) {\n  var extraArgs = slice.call(arguments, 3);\n\n  if (expr.charAt(0) === '!') {\n    // Allow '!prop' to become 'prop = !value'\n    expr = expr.slice(1).replace(/(\\s*\\||$)/, ' = !_value_$1');\n  } else {\n    expr = expr.replace(/(\\s*\\||$)/, ' = _value_$1');\n  }\n\n  // Add _value_ as the first extra argument\n  return exports.parse.apply(exports, [expr, globals, formatters, valueProperty].concat(extraArgs));\n};\n\n\nfunction getVariables(globals, extraArgs) {\n  var variables = {};\n\n  Object.keys(exports.globals).forEach(function(key) {\n    variables[key] = exports.globals[key];\n  });\n\n  if (globals) {\n    Object.keys(globals).forEach(function(key) {\n      variables[key] = globals[key];\n    });\n  }\n\n  extraArgs.forEach(function(key) {\n    variables[key] = null;\n  });\n\n  return variables;\n}\n\n\n\nfunction compileExpression(original, expr, globals, formatters, extraArgs) {\n  var func, args = ['_globals_', '_formatters_'].concat(extraArgs).concat(expr);\n\n  try {\n    func = Function.apply(null, args);\n  } catch (e) {\n    // Throws an error if the expression was not valid JavaScript\n    throw new Error('Bad expression: ' + original + '\\n' + 'Compiled expression:\\n' + expr + '\\n' + e.message);\n  }\n\n  return bindArguments(func, globals, formatters);\n}\n\n\n// a custom \"bind\" function to bind arguments to a function without binding the context\nfunction bindArguments(func) {\n  var args = slice.call(arguments, 1);\n  return function() {\n    return func.apply(this, args.concat(slice.call(arguments)));\n  }\n}\n",
    "\n// finds pipes that are not ORs (i.e. ` | ` not ` || `) for formatters\nvar pipeRegex = /\\|(\\|)?/g;\n\n// A string that would not appear in valid JavaScript\nvar placeholder = '@@@';\nvar placeholderRegex = new RegExp('\\\\s*' + placeholder + '\\\\s*');\n\n// determines whether an expression is a setter or getter (`name` vs `name = 'bob'`)\nvar setterRegex = /\\s=\\s/;\n\n// finds the parts of a formatter, name and args (e.g. `foo(bar)`)\nvar formatterRegex = /^([^\\(]+)(?:\\((.*)\\))?$/;\n\n// finds argument separators for formatters (`arg1, arg2`)\nvar argSeparator = /\\s*,\\s*/g;\n\n\n/**\n * Finds the formatters within an expression and converts them to the correct JavaScript equivalent.\n */\nexports.parseFormatters = function(expr) {\n  // Converts `name | upper | foo(bar)` into `name @@@ upper @@@ foo(bar)`\n  expr = expr.replace(pipeRegex, function(match, orIndicator) {\n    if (orIndicator) return match;\n    return placeholder;\n  });\n\n  // splits the string by \"@@@\", pulls of the first as the expr, the remaining are formatters\n  formatters = expr.split(placeholderRegex);\n  expr = formatters.shift();\n  if (!formatters.length) return expr;\n\n  // Processes the formatters\n  // If the expression is a setter the value will be run through the formatters\n  var setter = '';\n  var value = expr;\n\n  if (setterRegex.test(expr)) {\n    var parts = expr.split(setterRegex);\n    setter = parts[0] + ' = ';\n    value = parts[1];\n  }\n\n  // Processes the formatters\n  formatters.forEach(function(formatter) {\n    var match = formatter.trim().match(formatterRegex);\n\n    if (!match) {\n      throw new Error('Formatter is invalid: ' + formatter);\n    }\n\n    var formatterName = match[1];\n    var args = match[2] ? match[2].split(argSeparator) : [];\n\n    // Add the previous value as the first argument\n    args.unshift(value);\n\n    // If this is a setter expr, be sure to add the `isSetter` flag at the end of the formatter's arguments\n    if (setter) {\n      args.push(true);\n    }\n\n    // Set the value to become the result of this formatter, so the next formatter can wrap it.\n    // Call formatters in the current context.\n    value = '_formatters_.' + formatterName + '.call(this, ' + args.join(', ') + ')';\n  });\n\n  return setter + value;\n};\n",
    "var referenceCount = 0;\nvar currentReference = 0;\nvar currentIndex = 0;\nvar finishedChain = false;\nvar continuation = false;\nvar globals = null;\nvar defaultGlobals = {\n  return: null,\n  true: null,\n  false: null,\n  undefined: null,\n  null: null,\n  this: null,\n  window: null,\n  Math: null,\n  parseInt: null,\n  parseFloat: null,\n  isNaN: null,\n  Array: null,\n  typeof: null,\n  encodeURI: null,\n  encodeURIComponent: null,\n  Boolean: null,\n  String: null,\n  Number: null,\n  Infinity: null,\n  NaN: null,\n  _globals_: null,\n  _formatters_: null,\n  _value_: null,\n  new: null\n};\n\n\n// matches property chains (e.g. `name`, `user.name`, and `user.fullName().capitalize()`)\nvar propertyRegex = /((\\{|,|\\.)?\\s*)([a-z$_\\$](?:[a-z_\\$0-9\\.-]|\\[['\"\\d]+\\])*)(\\s*(:|\\(|\\[)?)/gi;\n/**\n * Broken down\n *\n * ((\\{|,|\\.)?\\s*)\n * prefix: matches on object literals so we can skip (in `{ foo: bar }` \"foo\" is not a property). Also picks up on\n * unfinished chains that had function calls or brackets we couldn't finish such as the dot in `.test` after the chain\n * `foo.bar().test`.\n *\n * ([a-z$_\\$](?:[a-z_\\$0-9\\.-]|\\[['\"\\d]+\\])*)\n * property chain: matches property chains such as the following (strings' contents are removed at this step)\n *   `foo, foo.bar, foo.bar[0], foo.bar[0].test, foo.bar[''].test`\n *   Does not match through functions calls or through brackets which contain variables.\n *   `foo.bar().test, foo.bar[prop].test`\n *   In these cases it would only match `foo.bar`, `.test`, and `prop`\n *\n * (\\s*(:|\\(|\\[)?)\n * postfix: matches trailing characters to determine if this is an object property or a function call etc. Will match\n * the colon after \"foo\" in `{ foo: 'bar' }`, the first parenthesis in `obj.foo(bar)`, the the first bracket in\n * `foo[bar]`.\n */\n\n// links in a property chain\nvar chainLinksRegex = /\\.|\\[/g;\n\n// the property name part of links\nvar chainLinkRegex = /\\.|\\[|\\(/;\n\nvar substitutions = {\n  ' && ': / and /g,\n  ' || ': / or /g,\n  ' === ': / is /g\n};\n\n\nexports.parseExpression = function(expr, _globals) {\n  // Reset all values\n  referenceCount = 0;\n  currentReference = 0;\n  currentIndex = 0;\n  finishedChain = false;\n  continuation = false;\n  globals = _globals;\n\n  expr = replaceSubstitutions(expr);\n  if (expr.indexOf(' = ') !== -1) {\n    var parts = expr.split(' = ');\n    var setter = parts[0];\n    var value = parts[1];\n    setter = parsePropertyChains(setter).replace(/^\\(|\\)$/g, '');\n    value = parsePropertyChains(value);\n    expr = setter + ' = ' + value;\n  } else {\n    expr = parsePropertyChains(expr);\n  }\n  expr = addReferences(expr)\n\n  // Reset after parse is done\n  globals = null;\n\n  return expr;\n};\n\n\n/**\n * Finds and parses the property chains in an expression.\n */\nfunction parsePropertyChains(expr) {\n  var parsedExpr = '', chain;\n\n  // allow recursion (e.g. into function args) by resetting propertyRegex\n  // This is more efficient than creating a new regex for each chain, I assume\n  var prevCurrentIndex = currentIndex;\n  var prevLastIndex = propertyRegex.lastIndex;\n\n  currentIndex = 0;\n  propertyRegex.lastIndex = 0;\n  while ((chain = nextChain(expr)) !== false) {\n    parsedExpr += chain;\n  }\n\n  // Reset indexes\n  currentIndex = prevCurrentIndex;\n  propertyRegex.lastIndex = prevLastIndex;\n  return parsedExpr;\n};\n\n\nfunction nextChain(expr) {\n  if (finishedChain) {\n    return (finishedChain = false);\n  }\n  var match = propertyRegex.exec(expr);\n  if (!match) {\n    finishedChain = true // make sure next call we return false\n    return expr.slice(currentIndex);\n  }\n\n  // `prefix` is `objIndicator` with the whitespace that may come after it.\n  var prefix = match[1];\n\n  // `objIndicator` is `{` or `,` and let's us know this is an object property\n  // name (e.g. prop in `{prop:false}`).\n  var objIndicator = match[2];\n\n  // `propChain` is the chain of properties matched (e.g. `this.user.email`).\n  var propChain = match[3];\n\n  // `postfix` is the `colonOrParen` with whitespace before it.\n  var postfix = match[4];\n\n  // `colonOrParen` matches the colon (:) after the property (if it is an object)\n  // or parenthesis if it is a function. We use `colonOrParen` and `objIndicator`\n  // to know if it is an object.\n  var colonOrParen = match[5];\n\n  match = match[0];\n\n  var skipped = expr.slice(currentIndex, propertyRegex.lastIndex - match.length);\n  currentIndex = propertyRegex.lastIndex;\n\n  // skips object keys e.g. test in `{test:true}`.\n  if (objIndicator && colonOrParen === ':') {\n    return skipped + match;\n  }\n\n  return skipped + parseChain(prefix, propChain, postfix, colonOrParen, expr);\n}\n\n\nfunction parseChain(prefix, propChain, postfix, paren, expr) {\n  // continuations after a function (e.g. `getUser(12).firstName`).\n  continuation = prefix === '.';\n  if (continuation) {\n    propChain = '.' + propChain;\n    prefix = '';\n  }\n\n  var links = splitLinks(propChain);\n  var newChain = '';\n\n  if (links.length === 1 && !continuation && !parens[paren]) {\n    link = links[0];\n    newChain = addThisOrGlobal(link);\n  } else {\n    if (!continuation) {\n      newChain = '(';\n    }\n\n    links.forEach(function(link, index) {\n      if (index !== links.length - 1) {\n        newChain += parsePart(link, index);\n      } else {\n        if (!parens[paren]) {\n          newChain += '_ref' + currentReference + link;\n        } else {\n          if (continuation && index === 0) {\n            index++;\n          }\n          postfix = postfix.replace(paren, '');\n          newChain += paren === '(' ? parseFunction(link, index, expr) : parseBrackets(link, index, expr);\n        }\n      }\n    });\n\n    if (expr.charAt(propertyRegex.lastIndex) !== '.') {\n      newChain += ')';\n    }\n  }\n\n  return prefix + newChain + postfix;\n}\n\n\nfunction splitLinks(chain) {\n  var index = 0;\n  var parts = [];\n  var match;\n  while (match = chainLinksRegex.exec(chain)) {\n    if (chainLinksRegex.lastIndex === 1) continue;\n    parts.push(chain.slice(index, chainLinksRegex.lastIndex - 1));\n    index = chainLinksRegex.lastIndex - 1;\n  }\n  parts.push(chain.slice(index));\n  return parts;\n}\n\n\nfunction addThisOrGlobal(chain) {\n  var prop = chain.split(chainLinkRegex).shift();\n  if (globals.hasOwnProperty(prop)) {\n    return globals[prop] === null ? chain : '_globals_.' + chain;\n  } else if (defaultGlobals.hasOwnProperty(prop)) {\n    return chain;\n  } else {\n    return 'this.' + chain;\n  }\n}\n\n\nvar parens = {\n  '(': ')',\n  '[': ']'\n};\n\n// Handles a function to be called in its correct scope\n// Finds the end of the function and processes the arguments\nfunction parseFunction(link, index, expr) {\n  var call = getFunctionCall(expr);\n\n  // Always call functions in the scope of the object they're a member of\n  if (index === 0) {\n    link = addThisOrGlobal(link);\n  } else {\n    link = '_ref' + currentReference + link;\n  }\n\n  var calledLink = link + '(~~insideParens~~)';\n\n  link = 'typeof ' + link + ' !== \\'function\\' ? void 0 : ' + calledLink;\n  var insideParens = call.slice(1, -1);\n\n  if (expr.charAt(propertyRegex.lastIndex) === '.') {\n    currentReference = ++referenceCount;\n    var ref = '_ref' + currentReference;\n    link = '(' + ref + ' = (' + link + ')) == null ? void 0 : ';\n  }\n\n  var ref = currentReference;\n  link = link.replace('~~insideParens~~', parsePropertyChains(insideParens));\n  currentReference = ref;\n  return link;\n}\n\n// Handles a bracketed expression to be parsed\nfunction parseBrackets(link, index, expr) {\n  var call = getFunctionCall(expr);\n  var insideBrackets = call.slice(1, -1);\n  var evaledLink = parsePart(link, index);\n  index += 1;\n  link = '[~~insideBrackets~~]';\n\n  if (expr.charAt(propertyRegex.lastIndex) === '.') {\n    link = parsePart(link, index);\n  } else {\n    link = '_ref' + currentReference + link;\n  }\n\n  link = evaledLink + link;\n\n  var ref = currentReference;\n  link = link.replace('~~insideBrackets~~', parsePropertyChains(insideBrackets));\n  currentReference = ref;\n  return link;\n}\n\n\n// returns the call part of a function (e.g. `test(123)` would return `(123)`)\nfunction getFunctionCall(expr) {\n  var startIndex = propertyRegex.lastIndex;\n  var open = expr.charAt(startIndex - 1);\n  var close = parens[open];\n  var endIndex = startIndex - 1;\n  var parenCount = 1;\n  while (endIndex++ < expr.length) {\n    var ch = expr.charAt(endIndex);\n    if (ch === open) parenCount++;\n    else if (ch === close) parenCount--;\n    if (parenCount === 0) break;\n  }\n  currentIndex = propertyRegex.lastIndex = endIndex + 1;\n  return open + expr.slice(startIndex, endIndex) + close;\n}\n\n\n\nfunction parsePart(part, index) {\n  // if the first\n  if (index === 0 && !continuation) {\n    part = addThisOrGlobal(part);\n  } else {\n    part = '_ref' + currentReference + part;\n  }\n\n  currentReference = ++referenceCount;\n  var ref = '_ref' + currentReference;\n  return '(' + ref + ' = ' + part + ') == null ? void 0 : ';\n}\n\n\nfunction replaceSubstitutions(expr) {\n  Object.keys(substitutions).forEach(function(replacement) {\n    expr = expr.replace(substitutions[replacement], replacement);\n  });\n  return expr;\n}\n\n\n// Prepends reference variable definitions\nfunction addReferences(expr) {\n  if (referenceCount) {\n    var refs = [];\n    for (var i = 1; i <= referenceCount; i++) {\n      refs.push('_ref' + i);\n    }\n    expr = 'var ' + refs.join(', ') + ';\\n' + expr;\n  }\n  return expr;\n}\n",
    "// finds all quoted strings\nvar quoteRegex = /(['\"\\/])(\\\\\\1|[^\\1])*?\\1/g;\n\n// finds all empty quoted strings\nvar emptyQuoteExpr = /(['\"\\/])\\1/g;\n\nvar strings = null;\n\n\n/**\n * Remove strings from an expression for easier parsing. Returns a list of the strings to add back in later.\n * This method actually leaves the string quote marks but empties them of their contents. Then when replacing them after\n * parsing the contents just get put back into their quotes marks.\n */\nexports.pullOutStrings = function(expr) {\n  if (strings) {\n    throw new Error('putInStrings must be called after pullOutStrings.');\n  }\n\n  strings = [];\n\n  return expr.replace(quoteRegex, function(str, quote) {\n    strings.push(str);\n    return quote + quote; // placeholder for the string\n  });\n};\n\n\n/**\n * Replace the strings previously pulled out after parsing is finished.\n */\nexports.putInStrings = function(expr) {\n  if (!strings) {\n    throw new Error('pullOutStrings must be called before putInStrings.');\n  }\n\n  expr = expr.replace(emptyQuoteExpr, function() {\n    return strings.shift();\n  });\n\n  strings = null;\n\n  return expr;\n};\n",
    "\nexports.Observations = require('./src/observations');\nexports.Observer = require('./src/observer');\nexports.ObservableHash = require('./src/observable-hash');\nexports.create = function() {\n  return new exports.Observations();\n};\n",
    "module.exports = ComputedProperty;\nvar Class = require('chip-utils/class');\n\n\n/**\n * An object which will be replaced by its computed value\n */\nfunction ComputedProperty() {}\n\nClass.extend(ComputedProperty, {\n\n  get isComputedProperty() {\n    return true;\n  },\n\n  /**\n   * Add a computed property to a computed object\n   * @param {Object} computedObject The object which this property is being added to\n   * @param {String} propertyName The name of the property on the object that will be set\n   * @return {Observer} An observer which can be bound to the computed object\n   */\n  addTo: function(observations, computedObject, propertyName, context) {\n    throw new Error('Abstract function is not implemented');\n  },\n\n  watch: function(observations, expression, obj, property, context) {\n    if (typeof expression === 'string') {\n      // This is a computed expression\n      return observations.createObserver(expression, function(value) {\n        if (value === undefined) {\n          delete obj[property];\n        } else {\n          obj[property] = value;\n        }\n      });\n    } else if (expression.isComputedProperty) {\n      // Add ComputedProperty's observer to the observers and bind if enabled\n      return expression.addTo(observations, obj, property, context);\n    }\n  }\n});\n",
    "module.exports = ExprProperty;\nvar ComputedProperty = require('./computed-property');\n\n/**\n * Assigns the result of the `thenExpression` to the object's property when the `ifExpression` is true.\n * @param {String} ifExpression The conditional expression use to determine when to call the `thenExpression`\n * @param {String|ComputedProperty} thenExpression The expression which will be executed when `if` is truthy and the\n *                                                 result set on the object. May also nest computed properties.\n */\nfunction ExprProperty(expression) {\n  this.expression = expression;\n}\n\n\nComputedProperty.extend(ExprProperty, {\n\n  addTo: function(observations, computedObject, propertyName, context) {\n    return this.watch(observations, this.expression, computedObject, propertyName, context);\n  }\n});\n",
    "module.exports = IfProperty;\nvar ComputedProperty = require('./computed-property');\n\n/**\n * Assigns the result of the `thenExpression` to the object's property when the `ifExpression` is true.\n * @param {String} ifExpression The conditional expression use to determine when to call the `thenExpression`\n * @param {String|ComputedProperty} thenExpression The expression which will be executed when `if` is truthy and the\n *                                                 result set on the object. May also nest computed properties.\n */\nfunction IfProperty(ifExpression, thenExpression) {\n  this.ifExpression = ifExpression;\n  this.thenExpression = thenExpression;\n}\n\n\nComputedProperty.extend(IfProperty, {\n\n  addTo: function(observations, computedObject, propertyName, context) {\n    var observer = this.watch(observations, this.thenExpression, computedObject, propertyName, context);\n\n    return observations.createObserver(this.ifExpression, function(value) {\n      if (value && !observer.context) {\n        observer.bind(context);\n      } else if (!value && observer.context) {\n        observer.unbind();\n        observer.sync();\n      }\n    });\n  }\n});\n",
    "module.exports = MapProperty;\nvar ComputedProperty = require('./computed-property');\n\n/**\n * Creates an object hash with the key being the value of the `key` property of each item in `sourceExpression` and the\n * value being the result of `expression`. `key` is optional, defaulting to \"id\" when not provided. `sourceExpression`\n * can resolve to an array or an object hash.\n * @param {Array|Object} sourceExpression An array or object whose members will be added to the map.\n * @param {String} keyExpression The name of the property to key against as values are added to the map.\n * @param {String} resultExpression [Optional] The expression evaluated against the array/object member whose value is\n *                                  added to the map. If not provided, the member will be added.\n * @return {Object} The object map of key=>value\n */\nfunction MapProperty(sourceExpression, keyExpression, resultExpression, removeExpression) {\n  var parts = sourceExpression.split(/\\s+in\\s+/);\n  this.sourceExpression = parts.pop();\n  this.itemName = parts.pop();\n  this.keyExpression = keyExpression;\n  this.resultExpression = resultExpression;\n  this.removeExpression = removeExpression;\n}\n\n\nComputedProperty.extend(MapProperty, {\n\n  addTo: function(observations, computedObject, propertyName, context) {\n    var map = {};\n    var observers = {};\n    computedObject[propertyName] = map;\n    var add = this.addItem.bind(this, observations, computedObject, map, observers, context);\n    var remove = this.removeItem.bind(this, observations, computedObject, map, observers, context);\n    return observations.createMemberObserver(this.sourceExpression, add, remove, this);\n  },\n\n  addItem: function(observations, computedObject, map, observers, context, item) {\n    if (!this.getKey) {\n      this.getKey = observations.getExpression(this.keyExpression);\n    }\n\n    var proxy;\n    if (this.itemName) {\n      proxy = Object.create(context);\n      proxy[this.itemName] = item;\n    } else {\n      proxy = Object.create(item);\n      proxy.$$ = context;\n    }\n\n    var key = item && this.getKey.call(proxy);\n    if (!key) {\n      return;\n    }\n\n    if (observers.hasOwnProperty(key)) {\n      this.removeObserver(observers, key);\n    }\n\n    if (this.resultExpression) {\n      var observer = this.watch(observations, this.resultExpression, map, key, proxy);\n      if (!observer) {\n        throw new TypeError('Invalid resultExpression for computed.map');\n      }\n\n      observer.bind(proxy);\n      observers[key] = observer;\n    } else {\n      map[key] = item;\n    }\n  },\n\n  removeItem: function(observations, computedObject, map, observers, context, item) {\n    var key = item && this.getKey.call(item);\n    if (key) {\n      this.removeObserver(observers, key);\n      if (this.removeExpression) {\n        observations.get(context, this.removeExpression);\n      }\n      delete map[key];\n    }\n  },\n\n  removeObserver: function(observers, key) {\n    var observer = observers[key];\n    if (observer) {\n      observer.unbind();\n      delete observers[key];\n    }\n  }\n});\n",
    "module.exports = WhenProperty;\nvar ComputedProperty = require('./computed-property');\n\n/**\n * Calls the `thenExpression` and assigns the results to the object's property when the `whenExpression` changes value\n * to anything other than a falsey value such as undefined. The return value of the `thenExpression` may be a Promise.\n *\n * @param {String} whenExpression The conditional expression use to determine when to call the `thenExpression`\n * @param {String} thenExpression The expression which will be executed when the `when` value changes and the result (or\n * the result of the returned promise) is set on the object.\n */\nfunction WhenProperty(whenExpression, thenExpression) {\n  if (!thenExpression) {\n    thenExpression = whenExpression;\n    whenExpression = 'true';\n  }\n\n  this.whenExpression = whenExpression;\n  this.thenExpression = thenExpression;\n}\n\n\nComputedProperty.extend(WhenProperty, {\n\n  addTo: function(observations, computedObject, propertyName, context) {\n    if (!this.thenMethod) {\n      this.thenMethod = observations.getExpression(this.thenExpression);\n    }\n\n    return observations.createObserver(this.whenExpression, function(value) {\n      if (value) {\n        var result = this.thenMethod.call(context);\n        if (result && result.then) {\n          result.then(function(value) {\n            computedObject[propertyName] = value;\n            observations.sync();\n          }, function(err) {\n            computedObject[propertyName] = undefined;\n            observations.sync();\n          });\n        } else {\n          computedObject[propertyName] = result;\n        }\n      } else {\n        computedObject[propertyName] = undefined;\n      }\n    }, this);\n  }\n});\n",
    "var ComputedProperty = require('./computed-properties/computed-property');\nvar ExprProperty = require('./computed-properties/expr');\nvar MapProperty = require('./computed-properties/map');\nvar IfProperty = require('./computed-properties/if');\nvar WhenProperty = require('./computed-properties/when');\n\n\nexports.create = function(observations) {\n\n  /**\n   * Create an object whose properties are dynamically updated with the values of the mapped expressions. An expression\n   * can be a simple JavaScript expression with formatters (see https://github.com/chip-js/expressions-js) or it can be\n   * a URL for watching the REST APIs. The object will have an array named `computedObservers` which contain all the\n   * observers created to watch the properties. The `computedObservers` array has two additional methods, `enable` and\n   * `disable` which will turn the binding on/off. When disabled the properties are reset to undefined.\n   * @param {Object} map A hash of computed properties, expressions or URLs, that will be set and updated on the object\n   * @param {Object} options Options for this computed object:\n   *   * enabled {Boolean} Whether to enable this computed object. Default is true.\n   * @return {Object} An object which will contain all the values of the computed properties\n   */\n  function computed(map, options) {\n    return computed.extend({}, map, options);\n  }\n\n\n  /**\n   * Extends an existing object with the values of the computed properties in the map.\n   * @param {Object} obj The object to extend, will create, update, and delete properties from the object as they change\n   * @param {Object} map A hash of computed properties that will be mapped onto the object\n   * @param {Object} options Options for this computed object:\n   *   * enabled {Boolean} Whether to enable this computed object. Default is true.\n   * @return {Object} Returns the object passed in\n   */\n  computed.extend = function(obj, map, options) {\n    if (!obj || !map) {\n      throw new TypeError('computed.extend expects `obj` and `map` to be objects');\n    }\n    ensureObservers(obj, options);\n\n    Object.keys(map).forEach(function(property) {\n      var expression = map[property];\n      var observer;\n\n      if (typeof expression === 'string') {\n        // This is a computed expression\n        observer = observations.createObserver(expression, function(value) {\n          obj[property] = value;\n        });\n      } else if (expression && expression.isComputedProperty) {\n        // Add ComputedProperty's observer to the observers and bind if enabled\n        observer = expression.addTo(observations, obj, property, obj);\n      } else {\n        obj[property] = expression;\n      }\n\n      if (observer) {\n        obj.computedObservers.push(observer);\n        if (obj.computedObservers.enabled) {\n          observer.bind(options && options.context || obj);\n        }\n      }\n    });\n\n    return obj;\n  };\n\n\n  /**\n   * Assigns the result of the expression to the computed object's property.\n   * @param {String} expression The string expression\n   * @return {ComputedProperty}\n   */\n  computed.expr = function(expression) {\n    return new ExprProperty(expression);\n  };\n\n\n  /**\n   * Creates an object hash with the key being the value of the `key` property of each item in `sourceExpression` and the\n   * value being the result of `expression`. `key` is optional, defaulting to \"id\" when not provided. `sourceExpression`\n   * can resolve to an array or an object hash.\n   * @param {Array|Object} sourceExpression An array or object whose members will be added to the map.\n   * @param {String} keyName [Optional] The name of the property to key against as values are added to the map. Defaults\n   *                         to \"id\"\n   * @param {String} expression The expression evaluated against the array/object member whose value is added to the map.\n   * @return {ComputedProperty}\n   */\n  computed.map = function(sourceExpression, keyName, resultExpression, removeExpression) {\n    return new MapProperty(sourceExpression, keyName, resultExpression, removeExpression);\n  };\n\n\n  /**\n   * Assigns the result of the `thenExpression` to the object's property when the `ifExpression` is true.\n   * @param {String} ifExpression The conditional expression use to determine when to call the `thenExpression`\n   * @param {String} thenExpression The expression which will be executed when `if` is truthy and the result set on the\n   * object.\n   * @return {ComputedProperty}\n   */\n  computed.if = function(ifExpression, thenExpression) {\n    return new IfProperty(ifExpression, thenExpression);\n  };\n\n\n  /**\n   * Calls the `thenExpression` and assigns the results to the object's property when the `whenExpression` changes value\n   * to anything other than a falsey value such as undefined. The return value of the `thenExpression` may be a Promise.\n   * @param {String} whenExpression The conditional expression use to determine when to call the `thenExpression`\n   * @param {String} thenExpression The expression which will be executed when the `when` value changes and the result\n   * (or the result of the returned promise) is set on the object.\n   * @return {ComputedProperty}\n   */\n  computed.when = function(whenExpression, thenExpression) {\n    return new WhenProperty(whenExpression, thenExpression);\n  };\n  // Alias when to async for readability and backwards compatability\n  computed.async = computed.when;\n\n\n  // Make the ComputedProperty class available for extension\n  computed.ComputedProperty = ComputedProperty;\n\n  return computed;\n};\n\n\n/**\n * Ensures the observers array exists on an object, creating it if not and adding disable/enable functions to enable and\n * disable observing.\n * @param {Object} obj The object which ought to have an observers array on it\n * @param {Object} options Options for this computed object:\n *   * enabled {Boolean} Whether to enable this computed object. Default is true.\n * @return {Object} The `obj` that was passed in\n */\nfunction ensureObservers(obj, options) {\n  if (!obj.computedObservers) {\n    Object.defineProperty(obj, 'computedObservers', { value: [] });\n    obj.computedObservers.enabled = (!options || options.enabled !== false);\n\n    // Restarts observing changes\n    obj.computedObservers.enable = function() {\n      if (!this.enabled) {\n        this.enabled = true;\n        this.forEach(function(observer) {\n          observer.bind(options && options.context || obj);\n        });\n      }\n    };\n\n    // Stops observing changes and resets all computed properties to undefined\n    obj.computedObservers.disable = function() {\n      if (this.enabled) {\n        this.enabled = false;\n        this.forEach(function(observer) {\n          observer.unbind();\n          observer.sync();\n        });\n      }\n    };\n  }\n  return obj;\n}\n",
    "module.exports = ObservableHash;\nvar Class = require('chip-utils/class');\nvar deepDelimiter = /(?:\\[\\]|\\{\\})\\.?/i;\n\n/**\n * An object for storing data to be accessed by an application. Has methods for easily computing and watching data\n * changes.\n * @param {Observations} observations An instance of the Observations class this has is bound to\n */\nfunction ObservableHash(observations) {\n  var enabled = true;\n  var _observers = [];\n  _observers.enabled = true;\n\n  Object.defineProperties(this, {\n    _context: { writable: true, value: this },\n    _observations: { value: observations },\n    _namespaces: { value: [] },\n    _observers: { value: _observers },\n    computedObservers: { value: _observers } // alias to work with the computed system\n  });\n}\n\n\nClass.extend(ObservableHash, {\n\n  /**\n   * Whether or not this hash is currently enabled and running the observations/computations. When disabled, watchers\n   * and all computed properties will be cleared out with `undefined`. The hash will be ready for garbage collection.\n   * @return {Boolean} If the hash is enabled, default `true`\n   */\n  get observersEnabled() {\n    return this._observers.enabled;\n  },\n  set observersEnabled(value) {\n    // Bind/unbind the observers for this hash\n    value ? this.observersStart() : this.observersStop(true);\n  },\n\n  /**\n   * Starts the observers watching their values\n   */\n  observersStart: function() {\n    this._observers.enabled = true;\n    this._observers.forEach(function(observer) {\n      observer.bind(this._context);\n    }, this);\n\n    // Set namespaced hashes to the same value\n    this._namespaces.forEach(function(namespace) {\n      this[namespace].observersResume();\n    }, this);\n  },\n\n  /**\n   * Stops the observers watching and responding to changes, optionally clearing out the values\n   * @param {Boolean} clearValues Whether to clear the values out to `undefined` or leave them as-is\n   */\n  observersStop: function(clearValues) {\n    this._observers.enabled = false;\n    this._observers.forEach(function(observer) {\n      observer.unbind();\n      if (clearValues) observer.sync();\n    });\n\n    // Set namespaced hashes to the same value\n    this._namespaces.forEach(function(namespace) {\n      this[namespace].observersPause(clearValues);\n    }, this);\n  },\n\n  /**\n   * Get the value of an expression\n   * @param {String} expression The JavaScript expression to evaluate\n   * @return {mixed} The value of the expression\n   */\n  get: function(expression) {\n    return this._observations.get(this._context, expression);\n  },\n\n  /**\n   * Set the value of an expression\n   * @param {String} expression The JavaScript expression to set\n   * @param {mixed} value The value you'd like to set the expression to\n   */\n  set: function(expression, value) {\n    return this._observations.set(this._context, expression, value);\n  },\n\n  /**\n   * Add computed properties to this hash. If `name` is provided it will add the computed properties to that namespace\n   * on the hash. Otherwise they will be added directly to the hash.\n   * @param {String} name [OPTIONAL] The namespace to add the computed properties under\n   * @param {Object} map The map of computed properties that will be set on this ObservableHash\n   */\n  addComputed: function(namespace, map) {\n    if (typeof namespace === 'string' && typeof map === 'object') {\n      if (!this[namespace]) {\n        this[namespace] = new ObservableHash(this._observations);\n        this[namespace].observersEnabled = this.observersEnabled;\n        this._namespaces.push(namespace);\n      }\n      this._observations.computed.extend(this[namespace], map, { context: this[namespace]._context });\n      return this[namespace];\n    } else if (namespace && typeof namespace === 'object') {\n      this._observations.computed.extend(this, namespace, { context: this._context });\n      return this;\n    } else {\n      throw new TypeError('addComputed must have a map object');\n    }\n  },\n\n  /**\n   * Watch this object for changes in the value of the expression\n   * @param {String} expression The expression to observe\n   * @param {Function} onChange The function which will be called when the expression value changes\n   * @return {Observer} The observer created\n   */\n  watch: function(expression, onChange, callbackContext) {\n    var observer = this._observations.createObserver(expression, onChange, callbackContext || this);\n    this._observers.push(observer);\n    if (this.observersEnabled) observer.bind(this._context);\n    return observer;\n  },\n\n  /**\n   * Observe an expression and call `onAdd` and `onRemove` whenever a member is added/removed from the array or object.\n   * @param {String} expression The expression to observe\n   * @param {Function} onAdd The function which will be called when a member is added to the source\n   * @param {Function} onRemove The function which will be called when a member is removed from the source\n   * @return {Observer} The observer created\n   */\n  track: function(expression, onAdd, onRemove, callbackContext) {\n    if (deepDelimiter.test(expression)) {\n      return this.trackDeeply(expression, onAdd, onRemove, callbackContext);\n    }\n    var observer = this._observations.createMemberObserver(expression, onAdd, onRemove, callbackContext || this);\n    this._observers.push(observer);\n    if (this.observersEnabled) observer.bind(this._context);\n    return observer;\n  },\n\n  /**\n   * Works like `track` but allows it to track deeply using `[]` and `{}` in the expression. Example:\n   * ```\n   * data.addComputed({\n   *   widgets: 'getArrayOfWidgets()',\n   *   widgetTags: computed.map('w in widgets', 'w.id', 'w.tags')\n   * });\n   * // know when a tag is added\n   * data.trackDeeply('widgets[].tags[].tagName', function(tagAdded) { console.log('tag added', tagAdded )});\n   * // widgetTags is an object hash of arrays, so we need to use two levels next to each other\n   * data.trackDeeply('widgetTags{}[].tagName', function(tagAdded) { console.log('tag added', tagAdded )});\n   * ```\n   * @param {String} expression The expression to observe with `{}` and `[]` indicating\n   * @param {Function} onAdd The function which will be called when a member is added to the source\n   * @param {Function} onRemove The function which will be called when a member is removed from the source\n   * @return {Observer} The observer created\n   */\n  trackDeeply: function(expression, onAdd, onRemove, callbackContext) {\n    if (!deepDelimiter.test(expression)) {\n      return this.track(expression, onAdd, onRemove, callbackContext);\n    }\n    callbackContext = callbackContext || this;\n    var observers = new WeakMap();\n    var observations = this._observations;\n    var steps = expression.split(deepDelimiter);\n    var lastIndex = steps.length - 1;\n\n    var removedCallback = function(item) {\n      var observer = observers.get(item);\n      if (observer) {\n        observer.unbind();\n        observer.sync();\n        observers.delete(item);\n      }\n    };\n\n    // Add a unique onAdd callback for each step of the observation\n    var addedCallbacks = steps.slice(1, -1).map(function(expr, index) {\n      // Observe the next set of members\n      return function(item) {\n        if (!item) return;\n        var observer = observations.observeMembers(\n          expr || 'this',\n          addedCallbacks[index + 1],\n          removedCallbacks[index + 1],\n          callbackContext\n        );\n        observers.set(item, observer);\n        observer.bind(item);\n        return observer;\n      };\n    });\n\n    // Removed callbacks are all the same except the last\n    var removedCallbacks = steps.map(function() {\n      return removedCallback;\n    });\n\n    // Add last callback\n    if (steps[lastIndex]) {\n      // Observe the item's property\n      addedCallbacks.push(function(item, key) {\n        if (!item) return;\n        var observer = observations.createObserver(steps[lastIndex], function(value, oldValue) {\n          if (oldValue != null && typeof onRemove === 'function') {\n            onRemove.call(callbackContext, oldValue, key, item);\n          }\n          if (value != null && typeof onAdd === 'function') {\n            onAdd.call(callbackContext, value, key, item);\n          }\n        });\n        observers.set(item, observer);\n        observer.bind(item);\n        return observer;\n      });\n    } else {\n      addedCallbacks.push(onAdd);\n      removedCallbacks[lastIndex] = onRemove;\n    }\n\n    var observer = observations.observeMembers(steps[0], addedCallbacks[0], removedCallbacks[0], callbackContext);\n    this._observers.push(observer);\n    if (this.observersEnabled) observer.bind(this._context);\n    return observer;\n  }\n\n});\n",
    "module.exports = Observations;\nvar Class = require('chip-utils/class');\nvar Observer = require('./observer');\nvar computed = require('./computed');\nvar ObservableHash = require('./observable-hash');\nvar expressions = require('expressions-js');\nvar requestAnimationFrame = global.requestAnimationFrame || setTimeout;\nvar cancelAnimationFrame = global.cancelAnimationFrame || clearTimeout;\n\n\nfunction Observations() {\n  // Bind all methods to this instance\n  Object.getOwnPropertyNames(this.constructor.prototype).forEach(function(name) {\n    if (typeof this[name] === 'function') {\n      this[name] = this[name].bind(this);\n    }\n  }, this);\n  this.globals = {};\n  this.formatters = {};\n  this.observers = [];\n  this.callbacks = [];\n  this.listeners = [];\n  this.syncing = false;\n  this.callbacksRunning = false;\n  this.rerun = false;\n  this.cycles = 0;\n  this.maxCycles = 10;\n  this.timeout = null;\n  this.pendingSync = null;\n  this.computed = computed.create(this);\n  this.expressions = expressions;\n}\n\n\nClass.extend(Observations, {\n  ObservableHash: ObservableHash,\n\n  /**\n   * Creates a new ObservableHash with useful methods for managing data using watch, track, and computed.\n   * @param {Object} computedMap [OPTIONAL] An initial computed map for this hash\n   * @return {ObservableHash} An object for putting your data on for accessibility\n   */\n  createHash: function(computedMap) {\n    var hash = new ObservableHash(this);\n    if (computedMap) hash.addComputed(computedMap);\n    return hash;\n  },\n\n  /**\n   * Observes any changes to the result of the expression on the context object and calls the callback.\n   * @param {Object} context The context to bind the expression against\n   * @param {String} expression The expression to observe\n   * @param {Function} onChange The function which will be called when the expression value changes\n   * @return {Observer} The observer created\n   */\n  watch: function(context, expression, onChange, callbackContext) {\n    var observer = this.createObserver(expression, onChange, callbackContext || context);\n    observer.bind(context);\n    return observer;\n  },\n\n  // Alias for `watch`, DEPRECATED\n  observe: function(context, expression, onChange, callbackContext) {\n    return this.watch(context, expression, onChange, callbackContext);\n  },\n\n  /**\n   * Observe an expression and call `onAdd` and `onRemove` whenever a member is added/removed from the array or object.\n   * @param {Object} context The context to bind the expression against\n   * @param {String} expression The expression to observe\n   * @param {Function} onAdd The function which will be called when a member is added to the source\n   * @param {Function} onRemove The function which will be called when a member is removed from the source\n   * @return {Observer} The observer created\n   */\n  track: function(context, expression, onAdd, onRemove, callbackContext) {\n    var observer = this.createMemberObserver(expression, onAdd, onRemove, callbackContext);\n    observer.bind(context);\n    return observer;\n  },\n\n  // Alias for `createMemberObserver`, DEPRECATED\n  observeMembers: function(expression, onAdd, onRemove, callbackContext) {\n    return this.createMemberObserver(expression, onAdd, onRemove, callbackContext);\n  },\n\n  /**\n   * Creates a new observer attached to this observations object. When the observer is bound to a context it will be\n   * added to this `observations` and synced when this `observations.sync` is called.\n   * @param {String} expression The expression to observe\n   * @param {Function} callback The function which will be called when the expression value changes\n   * @return {Observer} The observer\n   */\n  createObserver: function(expression, callback, callbackContext) {\n    return new Observer(this, expression, callback, callbackContext);\n  },\n\n  /**\n   * Observe an expression and call `onAdd` and `onRemove` whenever a member is added/removed from the array or object.\n   * @param {String} expression The expression to observe\n   * @param {Function} onAdd The function which will be called when a member is added to the source\n   * @param {Function} onRemove The function which will be called when a member is removed from the source\n   * @return {Observer} The observer\n   */\n  createMemberObserver: function(expression, onAdd, onRemove, callbackContext) {\n    if (!onAdd) onAdd = function(){};\n    if (!onRemove) onRemove = function(){};\n\n    var observer = this.createObserver(expression, function(source, oldValue, changes) {\n      if (changes) {\n        // call onRemoved on everything first\n        changes.forEach(function(change) {\n          if (change.type === 'splice') {\n            change.removed.forEach(function(item, index) {\n              // Only call onRemove if this item was removed completely, not if it just changed location in the array\n              if (source.indexOf(item) === -1) {\n                onRemove.call(callbackContext, item, index + change.index);\n              }\n            }, callbackContext);\n          } else {\n            if (change.oldValue != null) {\n              onRemove.call(callbackContext, change.oldValue, change.name);\n            }\n          }\n        });\n\n        // call onAdded second, allowing for items that changed location to be accurately processed\n        changes.forEach(function(change) {\n          if (change.type === 'splice') {\n            source.slice(change.index, change.index + change.addedCount).forEach(function(item, index) {\n              // Only call onAdd if this item was added, not if it changed location in the array\n              if (oldValue.indexOf(item) === -1) {\n                onAdd.call(callbackContext, item, index + change.index, source);\n              }\n            }, callbackContext);\n          } else {\n            var value = source[change.name];\n            if (value != null) {\n              onAdd.call(callbackContext, value, change.name, source);\n            }\n          }\n        });\n      } else if (Array.isArray(source)) {\n        source.forEach(onAdd, callbackContext);\n      } else if (source && typeof source === 'object') {\n        Object.keys(source).forEach(function(key) {\n          var value = source[key];\n          if (value != null) {\n            onAdd.call(callbackContext, value, key, source);\n          }\n        });\n      } else if (Array.isArray(oldValue)) {\n        oldValue.forEach(onRemove, callbackContext);\n      } else if (oldValue && typeof oldValue === 'object') {\n        // If undefined (or something that isn't an array/object) remove the observers\n        Object.keys(oldValue).forEach(function(key) {\n          var value = oldValue[key];\n          if (value != null) {\n            onRemove.call(callbackContext, value, key, oldValue);\n          }\n        });\n      }\n    });\n\n    observer.getChangeRecords = true;\n    return observer;\n  },\n\n\n  /**\n   * Parses an expression into a function using the globals and formatters objects associated with this instance of\n   * observations.\n   * @param {String} expression The expression string to parse into a function\n   * @param {Object} options Additional options to pass to the parser.\n   *                        `{ isSetter: true }` will make this expression a setter that accepts a value.\n   *                        `{ extraArgs: [ 'argName' ]` will make extra arguments to pass in to the function.\n   * @return {Function} A function that may be called to execute the expression (call it against a context using=\n   * `func.call(context)` in order to get the data from the context correct)\n   */\n  getExpression: function(expression, options) {\n    if (options && options.isSetter) {\n      return expressions.parseSetter(expression, this.globals, this.formatters, options.extraArgs);\n    } else if (options && options.extraArgs) {\n      var allArgs = [expression, this.globals, this.formatters].concat(options.extraArgs);\n      return expressions.parse.apply(expressions, allArgs);\n    } else {\n      return expressions.parse(expression, this.globals, this.formatters);\n    }\n  },\n\n\n  /**\n   * Gets the value of an expression from the given context object\n   * @param {Object} context The context object the expression will be evaluated against\n   * @param {String} expression The expression to evaluate\n   * @return {mixed} The result of the expression against the context\n   */\n  get: function(context, expression) {\n    return this.getExpression(expression).call(context);\n  },\n\n\n  /**\n   * Sets the value on the expression in the given context object\n   * @param {Object} context The context object the expression will be evaluated against\n   * @param {String} expression The expression to set a value with\n   * @param {mixed} value The value to set on the expression\n   * @return {mixed} The result of the expression against the context\n   */\n  set: function(source, expression, value) {\n    return this.getExpression(expression, { isSetter: true }).call(source, value);\n  },\n\n\n  // Schedules an observer sync cycle which checks all the observers to see if they've changed.\n  sync: function(callback) {\n    if (typeof callback === 'function') {\n      this.afterSync(callback);\n    }\n\n    if (this.pendingSync) {\n      return false;\n    }\n\n    this.pendingSync = requestAnimationFrame(this.syncNow);\n    return true;\n  },\n\n\n  // Runs the observer sync cycle which checks all the observers to see if they've changed.\n  syncNow: function(callback) {\n    if (typeof callback === 'function') {\n      this.afterSync(callback);\n    }\n\n    cancelAnimationFrame(this.pendingSync);\n    this.pendingSync = null;\n\n    if (this.syncing) {\n      this.rerun = true;\n      return false;\n    }\n\n    this.runSync();\n    return true;\n  },\n\n\n  runSync: function() {\n    this.syncing = true;\n    this.rerun = true;\n    this.cycles = 0;\n\n    var i, l;\n\n    // Allow callbacks to run the sync cycle again immediately, but stop at `maxCyles` (default 10) cycles so we don't\n    // run infinite loops\n    while (this.rerun) {\n      if (++this.cycles === this.maxCycles) {\n        throw new Error('Infinite observer syncing, an observer is calling Observer.sync() too many times');\n      }\n      this.rerun = false;\n      // the observer array may increase or decrease in size (remaining observers) during the sync\n      for (i = 0; i < this.observers.length; i++) {\n        this.observers[i].sync();\n      }\n    }\n\n    this.callbacksRunning = true;\n\n    var callbacks = this.callbacks;\n    this.callbacks = [];\n    while (callbacks.length) {\n      callbacks.shift()();\n    }\n\n    for (i = 0, l = this.listeners.length; i < l; i++) {\n      var listener = this.listeners[i];\n      listener();\n    }\n\n    this.callbacksRunning = false;\n    this.syncing = false;\n    this.cycles = 0;\n  },\n\n\n  // After the next sync (or the current if in the middle of one), run the provided callback\n  afterSync: function(callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n\n    if (this.callbacksRunning) {\n      this.sync();\n    }\n\n    this.callbacks.push(callback);\n  },\n\n\n  onSync: function(listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n\n    this.listeners.push(listener);\n  },\n\n\n  offSync: function(listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n\n    var index = this.listeners.indexOf(listener);\n    if (index !== -1) {\n      this.listeners.splice(index, 1).pop();\n    }\n  },\n\n\n  // Adds a new observer to be synced with changes. If `skipUpdate` is true then the callback will only be called when a\n  // change is made, not initially.\n  add: function(observer, skipUpdate) {\n    this.observers.push(observer);\n    if (!skipUpdate) {\n      observer.forceUpdateNextSync = true;\n      observer.sync();\n    }\n  },\n\n\n  // Removes an observer, stopping it from being run\n  remove: function(observer) {\n    var index = this.observers.indexOf(observer);\n    if (index !== -1) {\n      this.observers.splice(index, 1);\n      return true;\n    } else {\n      return false;\n    }\n  },\n});\n",
    "module.exports = Observer;\nvar Class = require('chip-utils/class');\nvar expressions = require('expressions-js');\nvar diff = require('differences-js');\n\n// # Observer\n\n// Defines an observer class which represents an expression. Whenever that expression returns a new value the `callback`\n// is called with the value.\n//\n// If the old and new values were either an array or an object, the `callback` also\n// receives an array of splices (for an array), or an array of change objects (for an object) which are the same\n// format that `Array.observe` and `Object.observe` return\n// <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe>.\nfunction Observer(observations, expression, callback, callbackContext) {\n  if (typeof expression === 'function') {\n    this.getter = expression;\n    this.setter = expression;\n  } else {\n    this.getter = expressions.parse(expression, observations.globals, observations.formatters);\n  }\n  this.observations = observations;\n  this.expression = expression;\n  this.callback = callback;\n  this.callbackContext = callbackContext;\n  this.getChangeRecords = false;\n  this.skip = false;\n  this.forceUpdateNextSync = false;\n  this.context = null;\n  this.oldValue = undefined;\n}\n\nClass.extend(Observer, {\n\n  get getChangeRecords() {\n    return this._getChangeRecords;\n  },\n\n  set getChangeRecords(value) {\n    this._getChangeRecords = Boolean(value);\n    if (value && this.oldValue) {\n      this.oldValue = diff.clone(this.oldValue);\n    }\n  },\n\n  // Binds this expression to a given context\n  bind: function(context, skipUpdate) {\n    this.context = context;\n    if (this.callback) {\n      this.observations.add(this, skipUpdate);\n    }\n  },\n\n  // Unbinds this expression\n  unbind: function() {\n    this.observations.remove(this);\n    this.context = null;\n  },\n\n  // Closes the observer, cleaning up any possible memory-leaks\n  close: function() {\n    this.unbind();\n    this.callback = null;\n    this.callbackContext = null;\n  },\n\n  // Returns the current value of this observer\n  get: function() {\n    if (this.context) {\n      return this.getter.call(this.context);\n    }\n  },\n\n  // Sets the value of this expression\n  set: function(value) {\n    if (!this.context) return;\n    if (this.setter === false) return;\n    if (!this.setter) {\n      try {\n        this.setter = typeof this.expression === 'string'\n          ? expressions.parseSetter(this.expression, this.observations.globals, this.observations.formatters)\n          : false;\n      } catch (e) {\n        this.setter = false;\n      }\n      if (!this.setter) return;\n    }\n\n    try {\n      var result = this.setter.call(this.context, value);\n    } catch(e) {\n      return;\n    }\n\n    // We can't expect code in fragments outside Observer to be aware of \"sync\" since observer can be replaced by other\n    // types (e.g. one without a `sync()` method, such as one that uses `Object.observe`) in other systems.\n    this.sync();\n    this.observations.sync();\n    return result;\n  },\n\n\n  // Instructs this observer to not call its `callback` on the next sync, whether the value has changed or not\n  skipNextSync: function() {\n    this.skip = true;\n  },\n\n\n  // Syncs this observer now, calling the callback immediately if there have been changes\n  sync: function() {\n    var value = this.get();\n\n    // Don't call the callback if `skipNextSync` was called on the observer\n    if (this.skip || !this.callback) {\n      this.skip = false;\n\n      if (this.getChangeRecords) {\n        // Store an immutable version of the value, allowing for arrays and objects to change instance but not content and\n        // still refrain from dispatching callbacks (e.g. when using an object in bind-class or when using array formatters\n        // in bind-each)\n        this.oldValue = diff.clone(value);\n      } else {\n        this.oldValue = value;\n      }\n    } else {\n      var change;\n      var useCompareBy = this.getChangeRecords &&\n                         this.compareBy &&\n                         Array.isArray(value) &&\n                         Array.isArray(this.oldValue);\n\n      if (useCompareBy) {\n        var compareExpression = this.compareBy;\n        var name = this.compareByName;\n        var index = this.compareByIndex || '__index__';\n        var ctx = this.context;\n        var globals = this.observations.globals;\n        var formatters = this.observations.formatters;\n        var oldValue = this.oldValue;\n        if (!name) {\n          name = '__item__';\n          // Turn \"id\" into \"__item__.id\"\n          compareExpression = name + '.' + compareExpression;\n        }\n\n        var getCompareValue = expressions.parse(compareExpression, globals, formatters, name, index);\n        changed = diff.values(value.map(getCompareValue, ctx), oldValue.map(getCompareValue, ctx));\n      } else if (this.getChangeRecords) {\n        changed = diff.values(value, this.oldValue);\n      } else {\n        changed = diff.basic(value, this.oldValue);\n      }\n\n      var oldValue = this.oldValue;\n\n      if (this.getChangeRecords) {\n        // Store an immutable version of the value, allowing for arrays and objects to change instance but not content and\n        // still refrain from dispatching callbacks (e.g. when using an object in bind-class or when using array formatters\n        // in bind-each)\n        this.oldValue = diff.clone(value);\n      } else {\n        this.oldValue = value;\n      }\n\n      // If an array has changed calculate the splices and call the callback.\n      if (!changed && !this.forceUpdateNextSync) return;\n      this.forceUpdateNextSync = false;\n      if (Array.isArray(changed)) {\n        this.callback.call(this.callbackContext, value, oldValue, changed);\n      } else {\n        this.callback.call(this.callbackContext, value, oldValue);\n      }\n    }\n  }\n});\n\nfunction mapToProperty(property) {\n  return function(item) {\n    return item && item[property];\n  }\n}\n",
    "module.exports = AnimatedBinding;\nvar animation = require('./util/animation');\nvar Binding = require('./binding');\nvar _super = Binding.prototype;\n\n/**\n * Bindings which extend AnimatedBinding have the ability to animate elements that are added to the DOM and removed from\n * the DOM. This allows menus to slide open and closed, elements to fade in or drop down, and repeated items to appear\n * to move (if you get creative enough).\n *\n * The following 5 methods are helper DOM methods that allow registered bindings to work with CSS transitions for\n * animating elements. If an element has the `animate` attribute or a matching JavaScript method, these helper methods\n * will set a class on the node to trigger the animation and/or call the JavaScript methods to handle it.\n *\n * An animation may be either a CSS transition, a CSS animation, or a set of JavaScript methods that will be called.\n *\n * If using CSS, classes are added and removed from the element. When an element is inserted it will receive the `will-\n * animate-in` class before being added to the DOM, then it will receive the `animate-in` class immediately after being\n * added to the DOM, then both clases will be removed after the animation is complete. When an element is being removed\n * from the DOM it will receive the `will-animate-out` and `animate-out` classes, then the classes will be removed once\n * the animation is complete.\n *\n * If using JavaScript, methods must be defined  to animate the element there are 3 supported methods which can b\n *\n * TODO cache by class-name (Angular)? Only support javascript-style (Ember)? Add a `will-animate-in` and\n * `did-animate-in` etc.?\n * IF has any classes, add the `will-animate-in|out` and get computed duration. If none, return. Cache.\n * RULE is use unique class to define an animation. Or attribute `animate=\"fade\"` will add the class?\n * `.fade.will-animate-in`, `.fade.animate-in`, `.fade.will-animate-out`, `.fade.animate-out`\n *\n * Events will be triggered on the elements named the same as the class names (e.g. `animate-in`) which may be listened\n * to in order to cancel an animation or respond to it.\n *\n * If the node has methods `animateIn(done)`, `animateOut(done)`, `animateMoveIn(done)`, or `animateMoveOut(done)`\n * defined on them then the helpers will allow an animation in JavaScript to be run and wait for the `done` function to\n * be called to know when the animation is complete.\n *\n * Be sure to actually have an animation defined for elements with the `animate` class/attribute because the helpers use\n * the `transitionend` and `animationend` events to know when the animation is finished, and if there is no animation\n * these events will never be triggered and the operation will never complete.\n */\nfunction AnimatedBinding(properties) {\n  var element = properties.node;\n  var animate = element.getAttribute(properties.fragments.animateAttribute);\n  var fragments = properties.fragments;\n\n  if (animate !== null) {\n    if (element.nodeName === 'TEMPLATE' || element.nodeName === 'SCRIPT') {\n      throw new Error('Cannot animate multiple nodes in a template or script. Remove the [animate] attribute.');\n    }\n\n    setTimeout(function() {\n      // Allow multiple bindings to animate by not removing until they have all been created\n      element.removeAttribute(properties.fragments.animateAttribute);\n    });\n\n    this.animate = true;\n\n    if (fragments.isBound('attribute', animate)) {\n      // javascript animation\n      this.animateExpression = fragments.codifyExpression('attribute', animate);\n    } else {\n      if (animate[0] === '.') {\n        // class animation\n        this.animateClassName = animate.slice(1);\n      } else if (animate) {\n        // registered animation\n        var animateObject = fragments.getAnimation(animate);\n        if (typeof animateObject === 'function') animateObject = new animateObject(this);\n        this.animateObject = animateObject;\n      }\n    }\n  }\n\n  Binding.call(this, properties);\n}\n\n\nBinding.extend(AnimatedBinding, {\n  init: function() {\n    _super.init.call(this);\n\n    if (this.animateExpression) {\n      this.animateObserver = new this.Observer(this.animateExpression, function(value) {\n        this.animateObject = value;\n      }, this);\n    }\n  },\n\n  bind: function(context) {\n    if (this.context == context) {\n      return;\n    }\n    _super.bind.call(this, context);\n\n    if (this.animateObserver) {\n      this.animateObserver.bind(context);\n    }\n  },\n\n  unbind: function() {\n    if (this.context === null) {\n      return;\n    }\n    _super.unbind.call(this);\n\n    if (this.animateObserver) {\n      this.animateObserver.unbind();\n    }\n  },\n\n  /**\n   * Helper method to remove a node from the DOM, allowing for animations to occur. `callback` will be called when\n   * finished.\n   */\n  animateOut: function(node, callback) {\n    if (node.firstViewNode) node = node.firstViewNode;\n\n    this.animateNode('out', node, callback);\n  },\n\n  /**\n   * Helper method to insert a node in the DOM before another node, allowing for animations to occur. `callback` will\n   * be called when finished. If `before` is not provided then the animation will be run without inserting the node.\n   */\n  animateIn: function(node, callback) {\n    if (node.firstViewNode) node = node.firstViewNode;\n    this.animateNode('in', node, callback, this);\n  },\n\n  /**\n   * Allow an element to use CSS3 transitions or animations to animate in or out of the page.\n   */\n  animateNode: function(direction, node, callback) {\n    var animateObject, className, classAnimateName, classWillName, whenDone,\n        methodAnimateName, methodWillName, methodDidName, dir, _this = this;\n\n    if (this.animateObject && typeof this.animateObject === 'object') {\n      animateObject = this.animateObject;\n      animateObject.fragments = this.fragments;\n    } else if (this.animateClassName) {\n      className = this.animateClassName;\n    } else if (typeof this.animateObject === 'string') {\n      className = this.animateObject;\n    }\n\n    classAnimateName = 'animate-' + direction;\n    classWillName = 'will-animate-' + direction;\n    dir = direction === 'in' ? 'In' : 'Out';\n    methodAnimateName = 'animate' + dir;\n    methodWillName = 'willAnimate' + dir;\n    methodDidName = 'didAnimate' + dir;\n    whenDone = function() {\n      if (animateObject && animateObject[methodDidName]) animateObject[methodDidName](node);\n      node.classList.remove(classAnimateName);\n      if (className) node.classList.remove(className);\n      if (callback) callback.call(_this);\n      node.dispatchEvent(new Event('animateend' + direction));\n    };\n\n    if (className) node.classList.add(className);\n\n    node.dispatchEvent(new Event('animatestart' + direction));\n\n    if (animateObject) {\n      animation.makeElementAnimatable(node);\n      if (typeof animateObject[methodWillName] === 'function') {\n        animateObject[methodWillName](node);\n      }\n      if (typeof animateObject[methodAnimateName] === 'function') {\n        node.classList.add(classAnimateName);\n        animateObject[methodAnimateName](node, whenDone);\n      }\n    } else {\n      node.classList.add(classWillName);\n      node.offsetWidth = node.offsetWidth;\n      node.classList.remove(classWillName);\n      node.classList.add(classAnimateName);\n      var duration = getDuration.call(_this, node, direction);\n      if (duration) {\n        onAnimationEnd(node, duration, whenDone);\n      } else {\n        requestAnimationFrame(whenDone);\n      }\n    }\n  }\n});\n\n\nvar transitionDurationName = 'transitionDuration';\nvar transitionDelayName = 'transitionDelay';\nvar animationDurationName = 'animationDuration';\nvar animationDelayName = 'animationDelay';\nvar transitionEventName = 'transitionend';\nvar animationEventName = 'animationend';\nvar style = document.documentElement.style;\n\n['webkit', 'moz', 'ms', 'o'].forEach(function(prefix) {\n  if (style.transitionDuration === undefined && style[prefix + 'TransitionDuration']) {\n    transitionDurationName = prefix + 'TransitionDuration';\n    transitionDelayName = prefix + 'TransitionDelay';\n    transitionEventName = prefix + 'transitionend';\n  }\n\n  if (style.animationDuration === undefined && style[prefix + 'AnimationDuration']) {\n    animationDurationName = prefix + 'AnimationDuration';\n    animationDelayName = prefix + 'AnimationDelay';\n    animationEventName = prefix + 'animationend';\n  }\n});\n\n\nfunction getDuration(node, direction) {\n  var milliseconds = this.clonedFrom['__animationDuration' + direction];\n  if (!milliseconds) {\n    // Recalc if node was out of DOM before and had 0 duration, assume there is always SOME duration.\n    var styles = window.getComputedStyle(node);\n    var seconds = Math.max(parseFloat(styles[transitionDurationName] || 0) +\n                           parseFloat(styles[transitionDelayName] || 0),\n                           parseFloat(styles[animationDurationName] || 0) +\n                           parseFloat(styles[animationDelayName] || 0));\n    milliseconds = seconds * 1000 || 0;\n    this.clonedFrom['__animationDuration' + direction] = milliseconds;\n  }\n  return milliseconds;\n}\n\n\nfunction onAnimationEnd(node, duration, callback) {\n  var onEnd = function(event) {\n    node.removeEventListener(transitionEventName, onEnd);\n    node.removeEventListener(animationEventName, onEnd);\n    clearTimeout(timeout);\n    callback();\n  };\n\n  // contingency plan\n  var timeout = setTimeout(onEnd, duration);\n\n  node.addEventListener(transitionEventName, onEnd);\n  node.addEventListener(animationEventName, onEnd);\n}\n",
    "module.exports = Binding;\nvar ElementController = require('./element-controller');\n\n/**\n * A binding is a link between an element and some data. Subclasses of Binding called binders define what a binding does\n * with that link. Instances of these binders are created as bindings on templates. When a view is stamped out from the\n * template the binding is \"cloned\" (it is actually extended for performance) and the `element`/`node` property is\n * updated to the matching element in the view.\n *\n * ### Properties\n *  * element: The element (or text node) this binding is bound to\n *  * node: Alias of element, since bindings may apply to text nodes this is more accurate\n *  * name: The attribute or element name (does not apply to matched text nodes)\n *  * match: The matched part of the name for wildcard attributes (e.g. `on-*` matching against `on-click` would have a\n *    match property equalling `click`). Use `this.camelCase` to get the match proerty camelCased.\n *  * expression: The expression this binding will use for its updates (does not apply to matched elements)\n *  * context: The context the exression operates within when bound\n */\nfunction Binding(properties) {\n  if (!properties.node || !properties.view) {\n    throw new TypeError('A binding must receive a node and a view');\n  }\n\n  // element and node are aliases\n  this._elementPath = initNodePath(properties.node, properties.view);\n  this.node = properties.node;\n  this.element = properties.node;\n  this.name = properties.name;\n  this.match = properties.match;\n  this.expression = properties.expression;\n  this.fragments = properties.fragments;\n  this.observations = properties.fragments.observations;\n  this.context = null;\n}\n\nElementController.extend(Binding, {\n  /**\n   * Default priority binders may override.\n   */\n  priority: 0,\n\n\n  /**\n   * Initialize a cloned binding. This happens after a compiled binding on a template is cloned for a view.\n   */\n  init: function() {\n    ElementController.call(this, this.observations);\n    this.observersEnabled = false;\n    this.listenersEnabled = false;\n\n    if (this.expression && this.updated !== Binding.prototype.updated) {\n      // An observer to observe value changes to the expression within a context\n      this.observer = this.watch(this.expression, this.updated, this);\n    }\n    this.created();\n  },\n\n  /**\n   * Clone this binding for a view. The element/node will be updated and the binding will be inited.\n   */\n  cloneForView: function(view) {\n    if (!view) {\n      throw new TypeError('A binding must clone against a view');\n    }\n\n    var node = view;\n    this._elementPath.forEach(function(index) {\n      node = node.childNodes[index];\n    });\n\n    var binding = Object.create(this);\n    binding.clonedFrom = this;\n    binding.view = view;\n    binding.element = node;\n    binding.node = node;\n    binding.init();\n    return binding;\n  },\n\n\n  // Bind this to the given context object\n  bind: function(context) {\n    if (this.context == context) {\n      return;\n    }\n\n    this.context = this._context = context;\n    this.bound();\n\n    this.observersEnabled = true;\n  },\n\n\n  // Unbind this from its context\n  unbind: function() {\n    if (this.context === null) {\n      return;\n    }\n    this.observersStop();\n    this.unbound();\n    this.context = this._context = null;\n  },\n\n  attach: function() {\n    this.listenersEnabled = true;\n    this.attached();\n  },\n\n  detach: function() {\n    this.listenersEnabled = false;\n    this.detached();\n  },\n\n  // Cleans up binding completely\n  dispose: function() {\n    this.unbind();\n    this.observersEnabled = false;\n    this.disposed();\n  },\n\n  sync: function() {\n    if (this.context && this.observer && this.updated !== Binding.prototype.updated) {\n      this.observer.sync();\n    }\n  },\n\n\n  // The function to run when the binding's element is compiled within a template\n  compiled: function() {},\n\n  // The function to run when the binding's element is created\n  created: function() {},\n\n  // The function to run when the expression's value changes\n  updated: function() {},\n\n  // The function to run when the binding is bound\n  bound: function() {},\n\n  // The function to run when the binding is unbound\n  unbound: function() {},\n\n  // The function to run when the binding is attached to the DOM\n  attached: function() {},\n\n  // The function to run when the binding is removed from the DOM\n  detached: function() {},\n\n  // The function to run when the binding is disposed\n  disposed: function() {},\n\n  // Helper methods\n\n  get camelCase() {\n    return (this.match || this.name || '').replace(/-+(\\w)/g, function(_, char) {\n      return char.toUpperCase();\n    });\n  },\n\n  observe: function(expression, callback, callbackContext) {\n    return this.watch(expression, callback, callbackContext);\n  }\n\n});\n\n\n\n\nvar indexOf = Array.prototype.indexOf;\n\n// Creates an array of indexes to help find the same element within a cloned view\nfunction initNodePath(node, view) {\n  var path = [];\n  while (node !== view) {\n    var parent = node.parentNode;\n    path.unshift(indexOf.call(parent.childNodes, node));\n    node = parent;\n  }\n  return path;\n}\n",
    "var slice = Array.prototype.slice;\nmodule.exports = compile;\n\n\n// Walks the template DOM replacing any bindings and caching bindings onto the template object.\nfunction compile(fragments, template) {\n  var walker = document.createTreeWalker(template, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT);\n  var bindings = [], currentNode, parentNode, previousNode;\n\n  // Reset first node to ensure it isn't a fragment\n  walker.nextNode();\n  walker.previousNode();\n\n  // find bindings for each node\n  do {\n    currentNode = walker.currentNode;\n    parentNode = currentNode.parentNode;\n    bindings.push.apply(bindings, getBindingsForNode(fragments, currentNode, template));\n\n    if (currentNode.parentNode !== parentNode) {\n      // currentNode was removed and made a template\n      walker.currentNode = previousNode || walker.root;\n    } else {\n      previousNode = currentNode;\n    }\n  } while (walker.nextNode());\n\n  return bindings;\n}\n\n\n\n// Find all the bindings on a given node (text nodes will only ever have one binding).\nfunction getBindingsForNode(fragments, node, view) {\n  var bindings = [];\n  var Binder, binding, expr, bound, match, attr, i, l;\n\n  if (node.nodeType === Node.TEXT_NODE) {\n    splitTextNode(fragments, node);\n\n    // Find any binding for the text node\n    if (fragments.isBound('text', node.nodeValue)) {\n      expr = fragments.codifyExpression('text', node.nodeValue);\n      node.nodeValue = '';\n      Binder = fragments.findBinder('text', expr);\n      if (Binder.expression) {\n        // the expression is the wildcard inside a text binder\n        expr = expr.match(Binder.expression)[1];\n      }\n      binding = new Binder({ node: node, view: view, expression: expr, fragments: fragments });\n      if (binding.compiled() !== false) {\n        bindings.push(binding);\n      }\n    }\n  } else {\n    // If the element is removed from the DOM, stop. Check by looking at its parentNode\n    var parent = node.parentNode;\n    var DefaultBinder = fragments.getAttributeBinder('__default__');\n    bound = [];\n\n    // Find any binding for the element\n    Binder = fragments.findBinder('element', node.tagName.toLowerCase());\n    if (Binder) {\n      bound.push([ Binder ]);\n    }\n\n    // Find and add any attribute bindings on an element. These can be attributes whose name matches a binding, or\n    // they can be attributes which have a binding in the value such as `href=\"/post/{{ post.id }}\"`.\n    var attributes = slice.call(node.attributes);\n    for (i = 0, l = attributes.length; i < l; i++) {\n      attr = attributes[i];\n      Binder = fragments.findBinder('attribute', attr.name, attr.value);\n      if (Binder) {\n        bound.push([ Binder, attr ]);\n      }\n    }\n\n    // Make sure to create and process them in the correct priority order so if a binding create a template from the\n    // node it doesn't process the others.\n    bound.sort(sortBindings);\n\n    for (i = 0; i < bound.length; i++) {\n      Binder = bound[i][0];\n      attr = bound[i][1];\n\n      if (attr) {\n        if (!node.hasAttribute(attr.name)) {\n          // If this was removed already by another binding, don't process.\n          continue;\n        }\n        var name = attr.name;\n        var value = attr.value;\n        if (Binder.expression) {\n          match = name.match(Binder.expression);\n          if (match) match = match[1];\n        } else {\n          match = null;\n        }\n\n        if (attr && node.hasAttribute(attr.name)) {\n          node.removeAttribute(attr.name);\n        }\n\n        binding = new Binder({\n          node: node,\n          view: view,\n          name: name,\n          match: match,\n          expression: value ? fragments.codifyExpression('attribute', value, Binder !== DefaultBinder) : null,\n          fragments: fragments\n        });\n      } else {\n        binding = new Binder({ node: node, view: view, fragments: fragments });\n      }\n\n      if (binding.compiled() !== false) {\n        bindings.push(binding);\n      } else if (attr && Binder !== DefaultBinder && fragments.isBound('attribute', value)) {\n        // Revert to default if this binding doesn't take\n        bound.push([ DefaultBinder, attr ]);\n      } else if (attr) {\n        node.setAttributeNode(attr);\n      }\n\n      if (node.parentNode !== parent) {\n        break;\n      }\n    }\n  }\n\n  return bindings;\n}\n\n\n// Splits text nodes with expressions in them so they can be bound individually, has parentNode passed in since it may\n// be a document fragment which appears as null on node.parentNode.\nfunction splitTextNode(fragments, node) {\n  if (!node.processed) {\n    node.processed = true;\n    var regex = fragments.binders.text._expr;\n    var content = node.nodeValue;\n    if (content.match(regex)) {\n      var match, lastIndex = 0, parts = [], fragment = document.createDocumentFragment();\n      while ((match = regex.exec(content))) {\n        parts.push(content.slice(lastIndex, regex.lastIndex - match[0].length));\n        parts.push(match[0]);\n        lastIndex = regex.lastIndex;\n      }\n      parts.push(content.slice(lastIndex));\n      parts = parts.filter(notEmpty);\n\n      node.nodeValue = parts[0];\n      for (var i = 1; i < parts.length; i++) {\n        var newTextNode = document.createTextNode(parts[i]);\n        newTextNode.processed = true;\n        fragment.appendChild(newTextNode);\n      }\n      node.parentNode.insertBefore(fragment, node.nextSibling);\n    }\n  }\n}\n\n\nfunction sortBindings(a, b) {\n  return b[0].prototype.priority - a[0].prototype.priority;\n}\n\nfunction notEmpty(value) {\n  return Boolean(value);\n}\n",
    "module.exports = ElementController;\nvar ObservableHash = require('observations-js').ObservableHash;\n\n\nfunction ElementController(observations) {\n  ObservableHash.call(this, observations);\n\n  Object.defineProperties(this, {\n    _listeners: { value: [] }\n  });\n  this._listeners.enabled = true;\n}\n\n\nObservableHash.extend(ElementController, {\n  get listenersEnabled() {\n    return this._listeners.enabled;\n  },\n\n  set listenersEnabled(value) {\n    if (this.enabled === value) return;\n    this._listeners.enabled = value;\n\n    // Bind/unbind the observers for this hash\n    if (value) {\n      this._listeners.forEach(function(item) {\n        item.targetRef = addListener(this, item.target, item.eventName, item.listener);\n      }, this);\n    } else {\n      this._listeners.forEach(function(item) {\n        removeListener(item.targetRef, item.eventName, item.listener);\n        delete item.targetRef;\n      }, this);\n    }\n  },\n\n\n  listen: function(target, eventName, listener, context) {\n    var element = this instanceof Node ? this : this.element;\n    if (typeof eventName === 'function') {\n      context = listener;\n      listener = eventName;\n      eventName = target;\n      target = element;\n    }\n\n    if (!target || typeof listener !== 'function') {\n      throw new TypeError('`listen([target], eventName, listener)` must have a function listener');\n    }\n\n    listener = listener.bind(context || this);\n\n    if (typeof target === 'string') {\n      // Listen on the element and match bubbled events against properties or query strings (like jquery.live)\n      var innerListener = listener;\n      var selector = target;\n      target = element;\n      listener = function(event) {\n        if (this[selector] instanceof Node && this[selector].contains(event.target)) {\n          innerListener(event);\n        } else if (event.target.closest(selector)) {\n          innerListener(event);\n        }\n      }.bind(this);\n    }\n\n    var listenerData = {\n      target: target,\n      eventName: eventName,\n      listener: listener,\n      targetRef: null\n    };\n\n    this._listeners.push(listenerData);\n\n    if (this.listenersEnabled) {\n      // If not bound will add on attachment\n      listenerData.targetRef = addListener(this, target, eventName, listener);\n    }\n  }\n});\n\n\nfunction getTarget(component, target) {\n  var element = component instanceof Node ? component : component.element;\n  if (typeof target === 'string') {\n    target = component[target] || element.querySelector(target);\n  } else if (target === Document) {\n    target = element.ownerDocument;\n  } else if (target === Window) {\n    target = element.ownerDocument.defaultView;\n  }\n  return target;\n}\n\nfunction addListener(component, target, eventName, listener) {\n  // If it's been moved to another document change targets to the relavent one\n  if ((target = getTarget(component, target))) {\n    target.addEventListener(eventName, listener);\n    return target;\n  }\n}\n\nfunction removeListener(target, eventName, listener) {\n  if (target) {\n    target.removeEventListener(eventName, listener);\n  }\n}\n",
    "module.exports = Fragments;\nrequire('./util/polyfills');\nvar Class = require('chip-utils/class');\nvar toFragment = require('./util/toFragment');\nvar animation = require('./util/animation');\nvar Template = require('./template');\nvar View = require('./view');\nvar Binding = require('./binding');\nvar AnimatedBinding = require('./animated-binding');\nvar compile = require('./compile');\nvar hasWildcardExpr = /(^|[^\\\\])\\*/;\nvar escapedWildcardExpr = /(^|[^\\\\])\\\\\\*/;\n\n/**\n * A Fragments object serves as a registry for binders and formatters\n * @param {Observations} observations An instance of Observations for tracking changes to the data\n */\nfunction Fragments(options) {\n  if (!options || !options.observations) {\n    throw new TypeError('Must provide an observations instance to Fragments in options.');\n  }\n\n  this.compiling = false;\n  this.observations = options.observations;\n  this.globals = options.observations.globals;\n  this.formatters = options.observations.formatters;\n  this.animations = {};\n  this.animateAttribute = 'animate';\n\n  this.binders = {\n    element: { _wildcards: [] },\n    attribute: { _wildcards: [], _expr: /{{\\s*(.*?)\\s*}}(?!})/g, _delimitersOnlyInDefault: false },\n    text: { _wildcards: [], _expr: /{{\\s*(.*?)\\s*}}(?!})/g }\n  };\n\n  // Text binder for text nodes with expressions in them\n  this.registerText('__default__', registerTextDefault);\n\n  function registerTextDefault(value) {\n    this.element.textContent = (value != null) ? value : '';\n  }\n\n  // Text binder for text nodes with expressions in them to be converted to HTML\n  this.registerText('{*}', function(value) {\n    if (this.content) {\n      this.content.remove();\n      this.content = null;\n    }\n\n    if (typeof value === 'string' && value || value instanceof Node) {\n      this.content = View.makeInstanceOf(toFragment(value));\n      this.element.parentNode.insertBefore(this.content, this.element.nextSibling);\n    }\n  });\n\n  // Catchall attribute binder for regular attributes with expressions in them\n  this.registerAttribute('__default__', function(value) {\n    if (value != null) {\n      this.element.setAttribute(this.name, value);\n    } else {\n      this.element.removeAttribute(this.name);\n    }\n  });\n\n  this.addOptions(options);\n}\n\nClass.extend(Fragments, {\n\n  addOptions: function(options) {\n    if (options) {\n      processOption(options.binders, this, 'registerAttribute');\n      processOption(options.formatters, this, 'registerFormatter');\n      processOption(options.animations, this, 'registerAnimation');\n    }\n  },\n\n  /**\n   * Takes an HTML string, an element, an array of elements, or a document fragment, and compiles it into a template.\n   * Instances may then be created and bound to a given context.\n   * @param {String|NodeList|HTMLCollection|HTMLTemplateElement|HTMLScriptElement|Node} html A Template can be created\n   * from many different types of objects. Any of these will be converted into a document fragment for the template to\n   * clone. Nodes and elements passed in will be removed from the DOM.\n   */\n  createTemplate: function(html) {\n    if (!html) {\n      throw new TypeError('Invalid html, cannot create a template from: ' + html);\n    }\n    var fragment = toFragment(html);\n    if (fragment.childNodes.length === 0) {\n      throw new Error('Cannot create a template from ' + html + ' because it is empty.');\n    }\n    var template = Template.makeInstanceOf(fragment);\n    this.compileTemplate(template);\n    return template;\n  },\n\n\n  /**\n   * Takes a template instance and pre-compiles it\n   * @param  {Template} template A template\n   * @return {Template} The template\n   */\n  compileTemplate: function(template) {\n    if (template && !template.compiled) {\n      // Set compiling flag on fragments, but don't turn it false until the outermost template is done\n      var lastCompilingValue = this.compiling;\n      this.compiling = true;\n      // Set this before compiling so we don't get into infinite loops if there is template recursion\n      template.compiled = true;\n      template.bindings = compile(this, template);\n      this.compiling = lastCompilingValue;\n    }\n    return template;\n  },\n\n\n  /**\n   * Compiles bindings on an element.\n   */\n  compileElement: function(element) {\n    if (!element.bindings) {\n      element.bindings = compile(this, element);\n      View.makeInstanceOf(element);\n    }\n\n    return element;\n  },\n\n\n  /**\n   * Compiles and binds an element which was not created from a template. Mostly only used for binding the document's\n   * html element.\n   */\n  bindElement: function(element, context) {\n    this.compileElement(element);\n\n    if (context) {\n      element.bind(context);\n    }\n\n    return element;\n  },\n\n\n  /**\n   * Observes an expression within a given context, calling the callback when it changes and returning the observer.\n   */\n  observe: function(context, expr, callback, callbackContext) {\n    if (typeof context === 'string') {\n      callbackContext = callback;\n      callback = expr;\n      expr = context;\n      context = null;\n    }\n    var observer = this.observations.createObserver(expr, callback, callbackContext);\n    if (context) {\n      observer.bind(context, true);\n    }\n    return observer;\n  },\n\n\n  /**\n   * Registers a binder for a given type and name. A binder is a subclass of Binding and is used to create bindings on\n   * an element or text node whose tag name, attribute name, or expression contents match this binder's name/expression.\n   *\n   * ### Parameters\n   *\n   *  * `type`: there are three types of binders: element, attribute, or text. These correspond to matching against an\n   *    element's tag name, an element with the given attribute name, or a text node that matches the provided\n   *    expression.\n   *\n   *  * `name`: to match, a binder needs the name of an element or attribute, or a regular expression that matches a\n   *    given text node. Names for elements and attributes can be regular expressions as well, or they may be wildcard\n   *    names by using an asterisk.\n   *\n   *  * `definition`: a binder is a subclass of Binding which overrides key methods, `compiled`, `created`, `updated`,\n   *    `bound`, and `unbound`. The definition may be an actual subclass of Binding or it may be an object which will be\n   *    used for the prototype of the newly created subclass. For many bindings only the `updated` method is overridden,\n   *    so by just passing in a function for `definition` the binder will be created with that as its `updated` method.\n   *\n   * ### Explaination of properties and methods\n   *\n   *   * `priority` may be defined as number to instruct some binders to be processed before others. Binders with\n   *   higher priority are processed first.\n   *\n   *   * `animated` can be set to `true` to extend the AnimatedBinding class which provides support for animation when\n   *   insertingand removing nodes from the DOM. The `animated` property only *allows* animation but the element must\n   *   have the `animate` attribute to use animation. A binding will have the `animate` property set to true when it is\n   *   to be animated. Binders should have fast paths for when animation is not used rather than assuming animation will\n   *   be used.\n   *\n   * Binders\n   *\n   * A binder can have 5 methods which will be called at various points in a binding's lifecycle. Many binders will\n   * only use the `updated(value)` method, so calling register with a function instead of an object as its third\n   * parameter is a shortcut to creating a binder with just an `update` method.\n   *\n   * Listed in order of when they occur in a binding's lifecycle:\n   *\n   *   * `compiled(options)` is called when first creating a binding during the template compilation process and receives\n   * the `options` object that will be passed into `new Binding(options)`. This can be used for creating templates,\n   * modifying the DOM (only subsequent DOM that hasn't already been processed) and other things that should be\n   * applied at compile time and not duplicated for each view created.\n   *\n   *   * `created()` is called on the binding when a new view is created. This can be used to add event listeners on the\n   * element or do other things that will persiste with the view through its many uses. Views may get reused so don't\n   * do anything here to tie it to a given context.\n   *\n   *   * `attached()` is called on the binding when the view is bound to a given context and inserted into the DOM. This\n   * can be used to handle context-specific actions, add listeners to the window or document (to be removed in\n   * `detached`!), etc.\n   *\n   *   * `updated(value, oldValue, changeRecords)` is called on the binding whenever the value of the expression within\n   * the attribute changes. For example, `bind-text=\"{{username}}\"` will trigger `updated` with the value of username\n   * whenever it changes on the given context. When the view is removed `updated` will be triggered with a value of\n   * `undefined` if the value was not already `undefined`, giving a chance to \"reset\" to an empty state.\n   *\n   *   * `detached()` is called on the binding when the view is unbound to a given context and removed from the DOM. This\n   * can be used to clean up anything done in `attached()` or in `updated()` before being removed.\n   *\n   * Element and attribute binders will apply whenever the tag name or attribute name is matched. In the case of\n   * attribute binders if you only want it to match when expressions are used within the attribute, add `onlyWhenBound`\n   * to the definition. Otherwise the binder will match and the value of the expression will simply be a string that\n   * only calls updated once since it will not change.\n   *\n   * Note, attributes which match a binder are removed during compile. They are considered to be binding definitions and\n   * not part of the element. Bindings may set the attribute which served as their definition if desired.\n   *\n   * ### Defaults\n   *\n   * There are default binders for attribute and text nodes which apply when no other binders match. They only apply to\n   * attributes and text nodes with expressions in them (e.g. `{{foo}}`). The default is to set the attribute or text\n   * node's value to the result of the expression. If you wanted to override this default you may register a binder with\n   * the name `\"__default__\"`.\n   *\n   * **Example:** This binding handler adds pirateized text to an element.\n   * ```javascript\n   * registry.registerAttribute('my-pirate', function(value) {\n   *   if (typeof value !== 'string') {\n   *     value = '';\n   *   } else {\n   *     value = value\n   *       .replace(/\\Bing\\b/g, \"in'\")\n   *       .replace(/\\bto\\b/g, \"t'\")\n   *       .replace(/\\byou\\b/, 'ye')\n   *       + ' Arrrr!';\n   *   }\n   *   this.element.textContent = value;\n   * });\n   * ```\n   *\n   * ```html\n   * <p my-pirate=\"{{post.body}}\">This text will be replaced.</p>\n   * ```\n   */\n  registerElement: function(name, definition) {\n    return this.registerBinder('element', name, definition);\n  },\n  registerAttribute: function(name, definition) {\n    return this.registerBinder('attribute', name, definition);\n  },\n  registerText: function(name, definition) {\n    return this.registerBinder('text', name, definition);\n  },\n  registerBinder: function(type, name, definition) {\n    if (!definition) throw new TypeError('Must provide a definition when registering a binder');\n    var binders = this.binders[type];\n    var superClass = definition.animated ? AnimatedBinding : Binding;\n\n    if (!binders) {\n      throw new TypeError('`type` must be one of ' + Object.keys(this.binders).join(', '));\n    }\n\n    if (typeof definition === 'function') {\n      if (definition.prototype instanceof Binding) {\n        superClass = definition;\n        definition = {};\n      } else {\n        definition = { updated: definition };\n      }\n    }\n\n    if (name === '__default__' && !definition.hasOwnProperty('priority')) {\n      definition.priority = -100;\n    }\n\n    if (binders[name]) {\n      this.unregisterBinder(type, name);\n    }\n\n    // Create a subclass of Binding (or another binder) with the definition\n    function Binder() {\n      superClass.apply(this, arguments);\n    }\n    superClass.extend(Binder, definition);\n\n    var expr;\n    if (name instanceof RegExp) {\n      expr = name;\n    } else if (hasWildcardExpr.test(name)) {\n      expr = new RegExp('^' + escapeRegExp(name).replace(escapedWildcardExpr, '$1(.*)') + '$');\n    }\n\n    if (expr) {\n      Binder.expression = expr;\n      binders._wildcards.push(Binder);\n      binders._wildcards.sort(this.bindingSort);\n    }\n\n    Binder.name = '' + name;\n    binders[name] = Binder;\n    return Binder;\n  },\n\n\n  /**\n   * Removes a binder that was added with `register()`. If an RegExp was used in register for the name it must be used\n   * to unregister, but it does not need to be the same instance.\n   */\n  unregisterElement: function(name) {\n    return this.unregisterBinder('element', name);\n  },\n  unregisterAttribute: function(name) {\n    return this.unregisterBinder('attribute', name);\n  },\n  unregisterText: function(name) {\n    return this.unregisterBinder('text', name);\n  },\n  unregisterBinder: function(type, name) {\n    var binder = this.getBinder(type, name), binders = this.binders[type];\n    if (!binder) return;\n    if (binder.expression) {\n      var index = binders._wildcards.indexOf(binder);\n      if (index >= 0) binders._wildcards.splice(index, 1);\n    }\n    delete binders[name];\n    return binder;\n  },\n\n\n  /**\n   * Returns a binder that was added with `register()` by type and name.\n   */\n  getElementBinder: function(name) {\n    return this.getBinder('element', name);\n  },\n  getAttributeBinder: function(name) {\n    return this.getBinder('attribute', name);\n  },\n  getTextBinder: function(name) {\n    return this.getBinder('text', name);\n  },\n  getBinder: function(type, name) {\n    var binders = this.binders[type];\n\n    if (!binders) {\n      throw new TypeError('`type` must be one of ' + Object.keys(this.binders).join(', '));\n    }\n\n    if (name && binders.hasOwnProperty(name)) {\n      return binders[name];\n    }\n  },\n\n\n  /**\n   * Find a matching binder for the given type. Elements should only provide name. Attributes should provide the name\n   * and value (value so the default can be returned if an expression exists in the value). Text nodes should only\n   * provide the value (in place of the name) and will return the default if no binders match.\n   */\n  findBinder: function(type, name, value) {\n    if (type === 'text' && value == null) {\n      value = name;\n      name = undefined;\n    }\n\n    if (name === this.animateAttribute) {\n      return;\n    }\n\n    var binder = this.getBinder(type, name), binders = this.binders[type];\n\n    if (!binder) {\n      var toMatch = (type === 'text') ? value : name;\n      binders._wildcards.some(function(wildcardBinder) {\n        if (toMatch.match(wildcardBinder.expression)) {\n          binder = wildcardBinder;\n          return true;\n        }\n      });\n    }\n\n    // don't use e.g. the `value` binder if there is no expression in the attribute value (e.g. `value=\"some text\"`)\n    if (binder &&\n        type === 'attribute' &&\n        binder.prototype.onlyWhenBound &&\n        !this.binders[type]._delimitersOnlyInDefault &&\n        !this.isBound(type, value)) {\n      return;\n    }\n\n    // Test if the attribute value is bound (e.g. `href=\"/posts/{{ post.id }}\"`)\n    if (!binder && value && (type === 'text' || this.isBound(type, value))) {\n      binder = this.getBinder(type, '__default__');\n    }\n\n    return binder;\n  },\n\n\n  /**\n   * A Formatter is stored to process the value of an expression. This alters the value of what comes in with a function\n   * that returns a new value. Formatters are added by using a single pipe character (`|`) followed by the name of the\n   * formatter. Multiple formatters can be used by chaining pipes with formatter names. Formatters may also have\n   * arguments passed to them by using the colon to separate arguments from the formatter name. The signature of a\n   * formatter should be `function(value, args...)` where args are extra parameters passed into the formatter after\n   * colons.\n   *\n   * *Example:*\n   * ```js\n   * registry.registerFormatter('uppercase', function(value) {\n   *   if (typeof value != 'string') return ''\n   *   return value.toUppercase()\n   * })\n   *\n   * registry.registerFormatter('replace', function(value, replace, with) {\n   *   if (typeof value != 'string') return ''\n   *   return value.replace(replace, with)\n   * })\n   * ```html\n   * <h1 bind-text=\"title | uppercase | replace:'LETTER':'NUMBER'\"></h1>\n   * ```\n   * *Result:*\n   * ```html\n   * <h1>GETTING TO KNOW ALL ABOUT THE NUMBER A</h1>\n   * ```\n   * TODO: old docs, rewrite, there is an extra argument named `setter` which will be true when the expression is being \"set\" instead of \"get\"\n   * A `valueFormatter` is like a formatter but used specifically with the `value` binding since it is a two-way binding. When\n   * the value of the element is changed a `valueFormatter` can adjust the value from a string to the correct value type for\n   * the controller expression. The signature for a `valueFormatter` includes the current value of the expression\n   * before the optional arguments (if any). This allows dates to be adjusted and possibley other uses.\n   *\n   * *Example:*\n   * ```js\n   * registry.registerFormatter('numeric', function(value) {\n   *   // value coming from the controller expression, to be set on the element\n   *   if (value == null || isNaN(value)) return ''\n   *   return value\n   * })\n   *\n   * registry.registerFormatter('date-hour', function(value) {\n   *   // value coming from the controller expression, to be set on the element\n   *   if ( !(currentValue instanceof Date) ) return ''\n   *   var hours = value.getHours()\n   *   if (hours >= 12) hours -= 12\n   *   if (hours == 0) hours = 12\n   *   return hours\n   * })\n   * ```html\n   * <label>Number Attending:</label>\n   * <input size=\"4\" bind-value=\"event.attendeeCount | numeric\">\n   * <label>Time:</label>\n   * <input size=\"2\" bind-value=\"event.date | date-hour\"> :\n   * <input size=\"2\" bind-value=\"event.date | date-minute\">\n   * <select bind-value=\"event.date | date-ampm\">\n   *   <option>AM</option>\n   *   <option>PM</option>\n   * </select>\n   * ```\n   */\n  registerFormatter: function (name, formatter) {\n    this.formatters[name] = formatter;\n  },\n\n\n  /**\n   * Unregisters a formatter.\n   */\n  unregisterFormatter: function (name) {\n    delete this.formatters[name];\n  },\n\n\n  /**\n   * Gets a registered formatter.\n   */\n  getFormatter: function (name) {\n    return this.formatters[name];\n  },\n\n\n  /**\n   * An Animation is stored to handle animations. A registered animation is an object (or class which instantiates into\n   * an object) with the methods:\n   *   * `willAnimateIn(element)`\n   *   * `animateIn(element, callback)`\n   *   * `didAnimateIn(element)`\n   *   * `willAnimateOut(element)`\n   *   * `animateOut(element, callback)`\n   *   * `didAnimateOut(element)`\n   *\n   * Animation is included with binders which are registered with the `animated` property set to `true` (such as `if`\n   * and `repeat`). Animations allow elements to fade in, fade out, slide down, collapse, move from one location in a\n   * list to another, and more.\n   *\n   * To use animation add an attribute named `animate` onto an element with a supported binder.\n   *\n   * ### CSS Animations\n   *\n   * If the `animate` attribute does not have a value or the value is a class name (e.g. `animate=\".my-fade\"`) then\n   * fragments will use a CSS transition/animation. Classes will be added and removed to trigger the animation.\n   *\n   *   * `.will-animate-in` is added right after an element is inserted into the DOM. This can be used to set the\n   *     opacity to `0.0` for example. It is then removed on the next animation frame.\n   *   * `.animate-in` is when `.will-animate-in` is removed. It can be used to set opacity to `1.0` for example. The\n   *     `animation` style can be set on this class if using it. The `transition` style can be set here. Note that\n   *     although the `animate` attribute is placed on an element with the `repeat` binder, these classes are added to\n   *     its children as they get added and removed.\n   *   * `.will-animate-out` is added before an element is removed from the DOM. This can be used to set the opacity to\n   *     `1` for example. It is then removed on the next animation frame.\n   *   * `.animate-out` is added when `.will-animate-out` is removed. It can be used to set opacity to `0.0` for\n   *     example. The `animation` style can be set on this class if using it. The `transition` style can be set here or\n   *     on another selector that matches the element. Note that although the `animate` attribute is placed on an\n   *     element with the `repeat` binder, these classes are added to its children as they get added and removed.\n   *\n   * If the `animate` attribute is set to a class name (e.g. `animate=\".my-fade\"`) then that class name will be added as\n   * a class to the element during animation. This allows you to use `.my-fade.will-animate-in`, `.my-fade.animate-in`,\n   * etc. in your stylesheets to use the same animation throughout your application.\n   *\n   * ### JavaScript Animations\n   *\n   * If you need greater control over your animations JavaScript may be used. It is recommended that CSS styles still be\n   * used by having your code set them manually. This allows the animation to take advantage of the browser\n   * optimizations such as hardware acceleration. This is not a requirement.\n   *\n   * In order to use JavaScript an object should be passed into the `animation` attribute using an expression. This\n   * object should have methods that allow JavaScript animation handling. For example, if you are bound to a context\n   * with an object named `customFade` with animation methods, your element should have `attribute=\"{{customFade}}\"`.\n   * The following is a list of the methods you may implement.\n   *\n   *   * `willAnimateIn(element)` will be called after an element has been inserted into the DOM. Use it to set initial\n   *     CSS properties before `animateIn` is called to set the final properties. This method is optional.\n   *   * `animateIn(element, callback)` will be called shortly after `willAnimateIn` if it was defined. Use it to set\n   *     final CSS properties.\n   *   * `animateOut(element, done)` will be called before an element is to be removed from the DOM. `done` must be\n   *     called when the animation is complete in order for the binder to finish removing the element. **Remember** to\n   *     clean up by removing any styles that were added before calling `done()` so the element can be reused without\n   *     side-effects.\n   *\n   * The `element` passed in will be polyfilled for with the `animate` method using\n   * https://github.com/web-animations/web-animations-js.\n   *\n   * ### Registered Animations\n   *\n   * Animations may be registered and used throughout your application. To use a registered animation use its name in\n   * the `animate` attribute (e.g. `animate=\"fade\"`). Note the only difference between a registered animation and a\n   * class registration is class registrations are prefixed with a dot (`.`). Registered animations are always\n   * JavaScript animations. To register an animation use `fragments.registerAnimation(name, animationObject)`.\n   *\n   * The Animation module comes with several common animations registered by default. The defaults use CSS styles to\n   * work correctly, using `element.animate`.\n   *\n   *   * `fade` will fade an element in and out over 300 milliseconds.\n   *   * `slide` will slide an element down when it is added and slide it up when it is removed.\n   *   * `slide-move` will move an element from its old location to its new location in a repeated list.\n   *\n   * Do you have another common animation you think should be included by default? Submit a pull request!\n   */\n  registerAnimation: function(name, animationObject) {\n    this.animations[name] = animationObject;\n  },\n\n\n  /**\n   * Unregisters an animation.\n   */\n  unregisterAnimation: function(name) {\n    delete this.animations[name];\n  },\n\n\n  /**\n   * Gets a registered animation.\n   */\n  getAnimation: function(name) {\n    return this.animations[name];\n  },\n\n\n  /**\n   * Prepare an element to be easier animatable (adding a simple `animate` polyfill if needed)\n   */\n  makeElementAnimatable: animation.makeElementAnimatable,\n\n\n  /**\n   * Sets the delimiters that define an expression. Default is `{{` and `}}` but this may be overridden. If empty\n   * strings are passed in (for type \"attribute\" only) then no delimiters are required for matching attributes, but the\n   * default attribute matcher will not apply to the rest of the attributes. TODO support different delimiters for the\n   * default attributes vs registered ones (i.e. allow regular attributes to use {{}} when bound ones do not need them)\n   */\n  setExpressionDelimiters: function(type, pre, post, onlyInDefault) {\n    if (type !== 'attribute' && type !== 'text') {\n      throw new TypeError('Expression delimiters must be of type \"attribute\" or \"text\"');\n    }\n\n    this.binders[type]._expr = new RegExp(escapeRegExp(pre) + '(.*?)' + escapeRegExp(post), 'g');\n    if (type === 'attribute') {\n      this.binders[type]._delimitersOnlyInDefault = !!onlyInDefault;\n    }\n  },\n\n\n  /**\n   * Tests whether a value has an expression in it. Something like `/user/{{user.id}}`.\n   */\n  isBound: function(type, value) {\n    if (type !== 'attribute' && type !== 'text') {\n      throw new TypeError('isBound must provide type \"attribute\" or \"text\"');\n    }\n    var expr = this.binders[type]._expr;\n    return Boolean(expr && value && value.match(expr));\n  },\n\n\n  /**\n   * The sort function to sort binders correctly\n   */\n  bindingSort: function(a, b) {\n    return b.prototype.priority - a.prototype.priority;\n  },\n\n\n  /**\n   * Converts an inverted expression from `/user/{{user.id}}` to `\"/user/\" + user.id`\n   */\n  codifyExpression: function(type, text, notDefault) {\n    if (type !== 'attribute' && type !== 'text') {\n      throw new TypeError('codifyExpression must use type \"attribute\" or \"text\"');\n    }\n\n    if (notDefault && this.binders[type]._delimitersOnlyInDefault) {\n      return text;\n    }\n\n    var expr = this.binders[type]._expr;\n    var match = text.match(expr);\n\n    if (!match) {\n      return '\"' + text.replace(/\"/g, '\\\\\"') + '\"';\n    } else if (match.length === 1 && match[0] === text) {\n      return text.replace(expr, '$1');\n    } else {\n      var newText = '\"', lastIndex = 0;\n      while ((match = expr.exec(text))) {\n        var str = text.slice(lastIndex, expr.lastIndex - match[0].length);\n        newText += str.replace(/\"/g, '\\\\\"');\n        newText += '\" + (' + match[1] + ' || \"\") + \"';\n        lastIndex = expr.lastIndex;\n      }\n      newText += text.slice(lastIndex).replace(/\"/g, '\\\\\"') + '\"';\n      return newText.replace(/^\"\" \\+ | \"\" \\+ | \\+ \"\"$/g, '');\n    }\n  }\n\n});\n\n// Takes a string like \"(\\*)\" or \"on-\\*\" and converts it into a regular expression.\nfunction escapeRegExp(text) {\n  return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n}\n\nfunction processOption(obj, fragments, methodName) {\n  if (obj) {\n    Object.keys(obj).forEach(function(name) {\n      fragments[methodName](name, obj[name]);\n    });\n  }\n}\n",
    "module.exports = Template;\nvar View = require('./view');\nvar Class = require('chip-utils/class');\n\n\n/**\n * ## Template\n * Takes an HTML string, an element, an array of elements, or a document fragment, and compiles it into a template.\n * Instances may then be created and bound to a given context.\n * @param {String|NodeList|HTMLCollection|HTMLTemplateElement|HTMLScriptElement|Node} html A Template can be created\n * from many different types of objects. Any of these will be converted into a document fragment for the template to\n * clone. Nodes and elements passed in will be removed from the DOM.\n */\nfunction Template() {\n  this.compiled = false;\n  this.pool = [];\n}\n\n\nClass.extend(Template, {\n\n  /**\n   * Creates a new view cloned from this template.\n   */\n  createView: function(doc) {\n    if (!doc) {\n      doc = document;\n    }\n    if (doc === document && this.pool.length) {\n      return this.pool.pop();\n    }\n\n    return View.makeInstanceOf(doc.importNode(this, true), this);\n  },\n\n  returnView: function(view) {\n    if (view.ownerDocument === document && this.pool.indexOf(view) === -1) {\n      this.pool.push(view);\n    }\n  }\n});\n",
    "// Helper methods for animation\nexports.makeElementAnimatable = makeElementAnimatable;\nexports.getComputedCSS = getComputedCSS;\nexports.animateElement = animateElement;\n\nfunction makeElementAnimatable(element) {\n  // Add polyfill just on this element\n  if (!element.animate) {\n    element.animate = animateElement;\n  }\n\n  // Not a polyfill but a helper\n  if (!element.getComputedCSS) {\n    element.getComputedCSS = getComputedCSS;\n  }\n\n  return element;\n}\n\n/**\n * Get the computed style on an element.\n */\nfunction getComputedCSS(styleName) {\n  if (this.ownerDocument.defaultView && this.ownerDocument.defaultView.opener) {\n    return this.ownerDocument.defaultView.getComputedStyle(this)[styleName];\n  }\n  return window.getComputedStyle(this)[styleName];\n}\n\n/**\n * Very basic polyfill for Element.animate if it doesn't exist. If it does, use the native.\n * This only supports two css states. It will overwrite existing styles. It doesn't return an animation play control. It\n * only supports duration, delay, and easing. Returns an object with a property onfinish.\n */\nfunction animateElement(css, options) {\n  var playback = { onfinish: null };\n\n  if (!Array.isArray(css) || css.length !== 2 || !options || !options.hasOwnProperty('duration')) {\n    Promise.resolve().then(function() {\n      if (playback.onfinish) {\n        playback.onfinish();\n      }\n    });\n    return playback;\n  }\n\n  var element = this;\n  var duration = options.duration || 0;\n  var delay = options.delay || 0;\n  var easing = options.easing;\n  var initialCss = css[0];\n  var finalCss = css[1];\n  var allCss = {};\n\n  Object.keys(initialCss).forEach(function(key) {\n    allCss[key] = true;\n    element.style[key] = initialCss[key];\n  });\n\n  // trigger reflow\n  element.offsetWidth;\n\n  var transitionOptions = ' ' + duration + 'ms';\n  if (easing) {\n    transitionOptions += ' ' + easing;\n  }\n  if (delay) {\n    transitionOptions += ' ' + delay + 'ms';\n  }\n\n  element.style.transition = Object.keys(finalCss).map(function(key) {\n    return key + transitionOptions;\n  }).join(', ');\n\n  Object.keys(finalCss).forEach(function(key) {\n    allCss[key] = true;\n    element.style[key] = finalCss[key];\n  });\n\n  setTimeout(function() {\n    Object.keys(allCss).forEach(function(key) {\n      element.style[key] = '';\n    });\n\n    if (playback.onfinish) {\n      playback.onfinish();\n    }\n  }, duration + delay);\n\n  return playback;\n}\n",
    "\n\n\n// Polyfill matches\nif (!Element.prototype.matches) {\n  Element.prototype.matches =\n    Element.prototype.matchesSelector ||\n    Element.prototype.webkitMatchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.oMatchesSelector;\n}\n\n// Polyfill closest\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function closest(selector) {\n    var element = this;\n    do {\n      if (element.matches(selector)) {\n        return element;\n      }\n    } while ((element = element.parentNode) && element.nodeType === Node.ELEMENT_NODE);\n    return null;\n  };\n}\n",
    "module.exports = toFragment;\n\n// Convert stuff into document fragments. Stuff can be:\n// * A string of HTML text\n// * An element or text node\n// * A NodeList or HTMLCollection (e.g. `element.childNodes` or `element.children`)\n// * A jQuery object\n// * A script element with a `type` attribute of `\"text/*\"` (e.g. `<script type=\"text/html\">My template code!</script>`)\n// * A template element (e.g. `<template>My template code!</template>`)\nfunction toFragment(html) {\n  if (typeof html === 'function') {\n    html = html();\n  }\n\n  if (html instanceof DocumentFragment) {\n    return html;\n  } else if (typeof html === 'string') {\n    return stringToFragment(html);\n  } else if (html instanceof Node) {\n    return nodeToFragment(html);\n  } else if ('length' in html) {\n    return listToFragment(html);\n  } else {\n    throw new TypeError('Unsupported Template Type: Cannot convert `' + html + '` into a document fragment.');\n  }\n}\n\n// Converts an HTML node into a document fragment. If it is a <template> node its contents will be used. If it is a\n// <script> node its string-based contents will be converted to HTML first, then used. Otherwise a clone of the node\n// itself will be used.\nfunction nodeToFragment(node) {\n  if (node.content instanceof DocumentFragment) {\n    return node.content;\n  } else if (node.tagName === 'SCRIPT') {\n    return stringToFragment(node.innerHTML);\n  } else {\n    var fragment = document.createDocumentFragment();\n    if (node.tagName === 'TEMPLATE') {\n      for (var i = 0, l = node.childNodes.length; i < l; i++) {\n        fragment.appendChild(node.childNodes[i]);\n      }\n    } else {\n      fragment.appendChild(node);\n    }\n    return fragment;\n  }\n}\n\n// Converts an HTMLCollection, NodeList, jQuery object, or array into a document fragment.\nfunction listToFragment(list) {\n  var fragment = document.createDocumentFragment();\n  for (var i = 0, l = list.length; i < l; i++) {\n    // Use toFragment since this may be an array of text, a jQuery object of `<template>`s, etc.\n    fragment.appendChild(toFragment(list[i]));\n    if (l === list.length + 1) {\n      // adjust for NodeLists which are live, they shrink as we pull nodes out of the DOM\n      i--;\n      l--;\n    }\n  }\n  return fragment;\n}\n\n// Converts a string of HTML text into a document fragment.\nvar stringToFragment = function(string) {\n  if (!string) {\n    var fragment = document.createDocumentFragment();\n    fragment.appendChild(document.createTextNode(''));\n    return fragment;\n  }\n  var templateElement;\n  templateElement = document.createElement('template');\n  templateElement.innerHTML = string;\n  return templateElement.content;\n};\n\n// If HTML Templates are not available (e.g. in IE) then use an older method to work with certain elements.\nif (!document.createElement('template').content instanceof DocumentFragment) {\n  stringToFragment = (function() {\n    var tagExp = /<([\\w:-]+)/;\n\n    // Copied from jQuery (https://github.com/jquery/jquery/blob/master/LICENSE.txt)\n    var wrapMap = {\n      option: [ 1, '<select multiple=\"multiple\">', '</select>' ],\n      legend: [ 1, '<fieldset>', '</fieldset>' ],\n      thead: [ 1, '<table>', '</table>' ],\n      tr: [ 2, '<table><tbody>', '</tbody></table>' ],\n      td: [ 3, '<table><tbody><tr>', '</tr></tbody></table>' ],\n      col: [ 2, '<table><tbody></tbody><colgroup>', '</colgroup></table>' ],\n      area: [ 1, '<map>', '</map>' ],\n      _default: [ 0, '', '' ]\n    };\n    wrapMap.optgroup = wrapMap.option;\n    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n    wrapMap.th = wrapMap.td;\n\n    return function stringToFragment(string) {\n      var fragment;\n      if (!string) {\n        fragment = document.createDocumentFragment();\n        fragment.appendChild(document.createTextNode(''));\n        return fragment;\n      }\n      var tag = string.match(tagExp);\n      var parts = wrapMap[tag] || wrapMap._default;\n      var depth = parts[0];\n      var prefix = parts[1];\n      var postfix = parts[2];\n      var div = document.createElement('div');\n      div.innerHTML = prefix + string + postfix;\n      while (depth--) {\n        div = div.lastChild;\n      }\n      fragment = document.createDocumentFragment();\n      while (div.firstChild) {\n        fragment.appendChild(div.firstChild);\n      }\n      return fragment;\n    };\n  })();\n}\n",
    "module.exports = View;\nvar Class = require('chip-utils/class');\n\n\n/**\n * ## View\n * A DocumentFragment with bindings.\n */\nfunction View(template) {\n  this.context = null;\n  if (!template) template = this;\n  this.template = template;\n  if (!this.template.bindings) this.template.bindings = [];\n  this.bindings = this.template.bindings.map(mapBinding.bind(this), this);\n\n  this.firstViewNode = this.firstChild;\n  this.lastViewNode = this.lastChild;\n  if (this.firstViewNode) {\n    this.firstViewNode.view = this;\n    this.lastViewNode.view = this;\n  }\n}\n\nfunction mapBinding(binding) {\n  return binding.cloneForView(this);\n}\n\n\nClass.extend(View, {\n\n  get inDOM() {\n    var parent = this.firstViewNode;\n    var doc = parent.ownerDocument;\n    while (parent && parent !== doc) {\n      parent = parent.parentNode || parent.host;\n    }\n    return parent === doc;\n  },\n\n  /**\n   * Removes a view from the DOM. A view is a DocumentFragment, so `remove()` returns all its nodes to itself.\n   */\n  remove: function() {\n    var node = this.firstViewNode;\n    var next;\n\n    if (node.parentNode !== this) {\n      // Remove all the nodes and put them back into this fragment\n      while (node) {\n        next = (node === this.lastViewNode) ? null : node.nextSibling;\n        this.appendChild(node);\n        node = next;\n      }\n    }\n\n    this.detached();\n  },\n\n\n  /**\n   * Removes a view (if not already removed) and adds the view to its template's pool.\n   */\n  dispose: function() {\n    // Make sure the view is removed from the DOM\n    this.bindings.forEach(this.disposeHelper);\n    this.context = null;\n\n    this.remove();\n    if (this.template) {\n      this.template.returnView(this);\n    }\n  },\n\n  disposeHelper: function(binding) {\n    binding.dispose();\n  },\n\n\n  /**\n   * Binds a view to a given context.\n   */\n  bind: function(context) {\n    this.context = context;\n    this.bindings.forEach(this.bindHelper.bind(this, context));\n  },\n\n  bindHelper: function(context, binding) {\n    binding.bind(context);\n  },\n\n\n  /**\n   * Unbinds a view from any context.\n   */\n  unbind: function() {\n    this.bindings.forEach(this.unbindHelper);\n    this.context = null;\n  },\n\n  unbindHelper: function(binding) {\n    binding.unbind();\n  },\n\n\n  /**\n   * Triggers the attached callback on the binders, call immediately after adding to the DOM\n   */\n  attached: function() {\n    if (!this._attached && this.inDOM) {\n      this._attached = true;\n      this.bindings.forEach(this.attachedHelper);\n    }\n  },\n\n  attachedHelper: function(binding) {\n    binding.attach();\n  },\n\n\n  /**\n   * Triggers the detached callback on the binders, call immediately after removing from the DOM\n   */\n  detached: function() {\n    if (this._attached && !this.inDOM) {\n      this._attached = false;\n      this.bindings.forEach(this.detachedHelper);\n    }\n  },\n\n  detachedHelper: function(binding) {\n    binding.detach();\n  },\n\n\n  /**\n   * Synchronizes this view against its context\n   */\n  sync: function() {\n    if (this.context === null) return;\n    this.bindings.forEach(this.syncHelper);\n  },\n\n  syncHelper: function(binding) {\n    binding.sync();\n  }\n});\n"
  ]
}